gt[gt == "1/1"] <- 2
# Transpose the numeric gt matrix
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
} else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
# Transpose the numeric gt matrix
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
} else if(tools::file_ext(data) == 'geno'){
Dat <- utils::read.table(data)
print("Geno file detected, proceeding to formatting. Note, PopGenHelpR assumes that your individuals in the geno file and
popmap are in the same order, please check to avoid erroneous inferences.")
} else {
stop("Please supply a geno file, vcf file, or vcfR object for analysis")
}
data <- HornedLizard_VCF
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
# Transpose the numeric gt matrix
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
} else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
# Transpose the numeric gt matrix
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
} else if(tools::file_ext(data) == 'geno'){
Dat <- utils::read.table(data)
print("Geno file detected, proceeding to formatting. Note, PopGenHelpR assumes that your individuals in the geno file and
popmap are in the same order, please check to avoid erroneous inferences.")
} else {
stop("Please supply a geno file, vcf file, or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != Inds_popmap)){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != Inds_popmap)], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
} else if(tools::file_ext(data) == 'geno'){
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
} else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
# Replace missing data value with NA
if(is.na(missing_value) == FALSE){
Dat[Dat == missing_value] <- NA
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
# Break into list with populations for each element
Dat_perpop <- list()
for(i in unique(P)){
Dat_perpop[[i]] <- Dat[which(Dat[,2] == i),]
}
message('Formatting has finished, moving onto calculations')
nind <- nrow(Dat)
npop <- length(Dat_perpop)
npop <- length(Dat_perpop)
q.freq <- matrix(nrow = length(Dat_perpop), ncol = length(Dat_perpop[3:ncol(Dat_perpop[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat_perpop)){
tmp <- Dat_perpop[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
# Set the names of the matrices
row.names(q.freq)  <- names(Dat_perpop)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
p.freq <- as.matrix(1-q.freq)
View(q.freq)
freq_comb <- cbind(q.freq, p.freq)
freq_comb2 <- freq_comb^2/r
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
# Get the number of loci
r <- ncol(q.freq)
freq_comb <- cbind(q.freq, p.freq)
freq_comb2 <- freq_comb^2/r
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- freq_comb[1,]*freq_comb[2,]/r
Jxy <- sum(Jxy)
ND <- Jxy/(sqrt(Jx*Jy))
-log(D)
-log(ND)
ND <- -log(Jxy/(sqrt(Jx*Jy)))
combn(rownames(q.freq)m=, n  = 2)
combn(rownames(q.freq)m, n  = 2)
combn(rownames(q.freq), n  = 2)
combn(rownames(q.freq), m = 2)
# Get the comparisons
Comps <- combn(rownames(q.freq), m = 2)
View(Comps)
# Set the results matrix
ND_res <- matrix(ncol = nrow(q.freq), nrow = nrow(q.freq))
View(ND_res)
i = 1
Comp <- Comps[,i]
which(rownames(q.freq) %in% Comp)
which(rownames(ND_res) == Comp[1])
View(ND_res)
rownames(ND_res) <- colnames(ND_res) <- row.names(q.freq)
which(rownames(ND_res) == Comp[1])
which(rownames(ND_res) == Comp[2])
row.idx <- which(rownames(ND_res) == Comp[2])
col.idx <- which(rownames(ND_res) == Comp[1])
Comp <- Comps[,i]
Pops2comp <- which(rownames(q.freq) %in% Comp)
Jx <- sum(freq_comb2[Pops2comp[1],])
Jy <- sum(freq_comb2[Pops2comp[2],])
Jxy <- freq_comb[Pops2comp[1],]*freq_comb[Pops2comp[2],]/r
Jxy <- sum(Jxy)
ND <- -log(Jxy/(sqrt(Jx*Jy)))
row.idx <- which(rownames(ND_res) == Comp[2])
col.idx <- which(rownames(ND_res) == Comp[1])
ND_res[row.idx, col.idx] <- ND
diag(ND_res) <- 0
for(i in 1:ncol(Comps)){
Comp <- Comps[,i]
Pops2comp <- which(rownames(q.freq) %in% Comp)
Jx <- sum(freq_comb2[Pops2comp[1],])
Jy <- sum(freq_comb2[Pops2comp[2],])
Jxy <- freq_comb[Pops2comp[1],]*freq_comb[Pops2comp[2],]/r
Jxy <- sum(Jxy)
ND <- -log(Jxy/(sqrt(Jx*Jy)))
row.idx <- which(rownames(ND_res) == Comp[2])
col.idx <- which(rownames(ND_res) == Comp[1])
ND_res[row.idx, col.idx] <- ND
diag(ND_res) <- 0
}
Glight <- vcfR::vcfR2genlight(VCF)
Glight <- vcfR::vcfR2genlight(HornedLizard_VCF)
Glight@pop <- as.factor(HornedLizard_Pop$Population)
Stampp_ND <- StAMPP::stamppNeisD(Glight)
View(Stampp_ND)
NeiD <- function(Dat){
nind <- nind
npop <- length(Dat)
# Calculate population Nei's D
# Create a matrix to store the alternate allele frequency for each population
q.freq <- matrix(nrow = length(Dat), ncol = length(Dat[3:ncol(Dat[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat)){
tmp <- Dat[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
# Set the names of the matrices
row.names(q.freq)  <- names(Dat)
# Get the comparisons
Comps <- combn(rownames(q.freq), m = 2)
# Set the results matrix
ND_res <- matrix(ncol = nrow(q.freq), nrow = nrow(q.freq))
rownames(ND_res) <- colnames(ND_res) <- row.names(q.freq)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
p.freq <- as.matrix(1-q.freq)
# Get the number of loci
r <- ncol(q.freq)
freq_comb <- cbind(q.freq, p.freq)
freq_comb2 <- freq_comb^2/r
for(i in 1:ncol(Comps)){
Comp <- Comps[,i]
Pops2comp <- which(rownames(q.freq) %in% Comp)
Jx <- sum(freq_comb2[Pops2comp[1],])
Jy <- sum(freq_comb2[Pops2comp[2],])
Jxy <- freq_comb[Pops2comp[1],]*freq_comb[Pops2comp[2],]/r
Jxy <- sum(Jxy)
ND <- -log(Jxy/(sqrt(Jx*Jy)))
row.idx <- which(rownames(ND_res) == Comp[2])
col.idx <- which(rownames(ND_res) == Comp[1])
ND_res[row.idx, col.idx] <- ND
diag(ND_res) <- 0
}
return(ND_res)
}
Test <- NeiD(Dat_perpop)
View(Test)
NesiD <- function(Dat){
nind <- nind
npop <- length(Dat)
# Calculate population Nei's D
# Create a matrix to store the alternate allele frequency for each population
q.freq <- matrix(nrow = length(Dat), ncol = length(Dat[3:ncol(Dat[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat)){
tmp <- Dat[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
# Set the names of the matrices
row.names(q.freq)  <- names(Dat)
# Get the comparisons
Comps <- combn(rownames(q.freq), m = 2)
# Set the results matrix
ND_res <- matrix(ncol = nrow(q.freq), nrow = nrow(q.freq))
rownames(ND_res) <- colnames(ND_res) <- row.names(q.freq)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
p.freq <- as.matrix(1-q.freq)
# Get the number of loci
r <- ncol(q.freq)
freq_comb <- cbind(q.freq, p.freq)
freq_comb2 <- freq_comb^2/r
for(i in 1:ncol(Comps)){
Comp <- Comps[,i]
Pops2comp <- which(rownames(q.freq) %in% Comp)
Jx <- sum(freq_comb2[Pops2comp[1],])
Jy <- sum(freq_comb2[Pops2comp[2],])
Jxy <- freq_comb[Pops2comp[1],]*freq_comb[Pops2comp[2],]/r
Jxy <- sum(Jxy)
ND <- -log(Jxy/(sqrt(Jx*Jy)))
row.idx <- which(rownames(ND_res) == Comp[2])
col.idx <- which(rownames(ND_res) == Comp[1])
ND_res[row.idx, col.idx] <- ND
diag(ND_res) <- 0
}
return(ND_res)
}
ND_pop <- NeisD(Dat_perpop)
NeisD <- function(Dat){
nind <- nind
npop <- length(Dat)
# Calculate population Nei's D
# Create a matrix to store the alternate allele frequency for each population
q.freq <- matrix(nrow = length(Dat), ncol = length(Dat[3:ncol(Dat[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat)){
tmp <- Dat[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
# Set the names of the matrices
row.names(q.freq)  <- names(Dat)
# Get the comparisons
Comps <- combn(rownames(q.freq), m = 2)
# Set the results matrix
ND_res <- matrix(ncol = nrow(q.freq), nrow = nrow(q.freq))
rownames(ND_res) <- colnames(ND_res) <- row.names(q.freq)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
p.freq <- as.matrix(1-q.freq)
# Get the number of loci
r <- ncol(q.freq)
freq_comb <- cbind(q.freq, p.freq)
freq_comb2 <- freq_comb^2/r
for(i in 1:ncol(Comps)){
Comp <- Comps[,i]
Pops2comp <- which(rownames(q.freq) %in% Comp)
Jx <- sum(freq_comb2[Pops2comp[1],])
Jy <- sum(freq_comb2[Pops2comp[2],])
Jxy <- freq_comb[Pops2comp[1],]*freq_comb[Pops2comp[2],]/r
Jxy <- sum(Jxy)
ND <- -log(Jxy/(sqrt(Jx*Jy)))
row.idx <- which(rownames(ND_res) == Comp[2])
col.idx <- which(rownames(ND_res) == Comp[1])
ND_res[row.idx, col.idx] <- ND
diag(ND_res) <- 0
}
return(ND_res)
}
ND_pop <- NeisD(Dat_perpop)
View(Dat)
## Run Nei's D per individual
Dat_perind <- Dat
Dat_perind$P <- Dat_perind$Inds
Dat_perind2 <- list()
for(i in unique(Dat_perind)){
Dat_perind2[[i]] <- Dat_perind[which(Dat_perind[,2] == i),]
}
Dat_perind2 <- list()
for(i in unique(Dat_perind$P)){
Dat_perind2[[i]] <- Dat_perind[which(Dat_perind[,2] == i),]
}
ND_ind <- NeisD(Dat_perind2)
View(ND_ind)
Stampp_ND_ind <- StAMPP::stamppNeisD(Glight, pop = F)
View(Stampp_ND_ind)
### Jost's D
Genind <- vcfR::vcfR2genind(HornedLizard_VCF)
Genind@pop <- as.factor(HornedLizard_Pop$Population)
loci <- seploc(Genind)
loci <- adegenet::seploc(Genind)
View(loci)
Mmod.dat <- Genind[complete.cases(Genind@tab)]
View(Mmod.dat)
afreqs <- apply(Genind@tab, 2, "/", 2)
View(afreqs)
Genind@tab
afreqs <- apply(Mmod.dat@tab, 2, "/", 2)
n_by_pop <-  table(pop(Mmod.dat))
n_by_pop <-  table(adegenet::pop(Mmod.dat))
harmN <- harmonic_mean(n_by_pop[n_by_pop >0])
harmN <- harmonic.mean(n_by_pop[n_by_pop >0])
harmN <- psych::harmonic.mean(n_by_pop[n_by_pop >0])
harmonic_mean <- function(x, na.rm=TRUE){
if(na.rm){
x <- x[!is.na(x)]
} else {
if(any(is.na(x))) return(NA)
}
if(any(x < 0)){
return(NA)
}
1/mean(1/x)
}
harmN <- harmonic_mean(n_by_pop[n_by_pop >0])
n <- 3
a <- apply(afreqs, 2, function(A) tapply(A, adegenet::pop(x), mean))
a <- apply(afreqs, 2, function(A) tapply(A, adegenet::pop(Mmod.dat), mean))
View(a)
HpS <- mean(1 - rowSums(a^2))
Hs_est <- (2*harmN/(2*harmN-1))*HpS
HpT <- 1 - sum(colMeans(a)^2)
Ht_est <- HpT + Hs_est/(2*harmN*n)
MMOD.D <- mmod::D_Jost(Genind)
View(MMOD.D)
MMOD.D[["per.locus"]]
MMOD.D[["global.het"]]
Test <- MMOD.D$per.locus
MMOD_Dres <- mmod::pairwise_D(Genind)
MMOD_Dres
utils::combn(1:3, 2, function(p) FXN(x[pop=p], ...)[[VAL]])
pairwise_fxn <- function(x, linearized=FALSE, FXN, VAL, ...){
n.pops <- nPop(x)
#all combinations
res <- utils::combn(1:n.pops, 2, function(p) FXN(x[pop=p], ...)[[VAL]])
attributes(res) <- list(class="dist", Diag=FALSE, Upper=FALSE,
Labels=popNames(x),Size=n.pops)
if(linearized){
return(res/(1-res))
}
res
}
View(MMOD.D)
MMOD.D$global.het
pairwise_fxn(Mmod.dat, linearized, D_Jost, "global.het", hsht_mean=hsht_mean)
library(adegenet)
pairwise_fxn(Mmod.dat, linearized, D_Jost, "global.het", hsht_mean=hsht_mean)
pairwise_fxn(Mmod.dat, linearized, mmod::D_Jost, "global.het", hsht_mean=hsht_mean)
pairwise_fxn(Mmod.dat, linearized, mmod::D_Jost, "global.het", mmod::hsht_mean=hsht_mean)
View(Genind)
Genind@tab
Genind@pop
MMod.dat.pops12 <- tab(Genind[1:52])
View(MMod.dat.pops12)
MMod.dat.pops12 <- poppr::popsub(Genind, sublist = c("South", "East"))
SE_D <- mmod::D_Jost(MMod.dat.pops12)
View(SE_D)
n_by_pop[n_by_pop >0]
mean(n_by_pop[n_by_pop >0])
harmN <- harmonic_mean(n_by_pop[n_by_pop >0])
harmonic_mean(n_by_pop[n_by_pop >0])
1/(mean(1/n_by_pop[n_by_pop >0]))
table(Dat$P)
n.perpop <- table(Dat$P)
n.pop <- unique(Dat$P)
View(a)
View(Dat)
View(a)
lapply(Dat_perpop, nrow)
Tab <- lapply(Dat_perpop, nrow)
Tab <- as.data.frame(lapply(Dat_perpop, nrow))
View(Tab)
p.freq <- matrix(nrow = length(Dat_perpop), ncol = length(Dat_perpop[3:ncol(Dat_perpop[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat_perpop)){
tmp <- Dat_perpop[[i]]
# Get frequency of alternate alleles
p.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 0, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
View(p.freq)
q.freq <- matrix(nrow = length(Dat), ncol = length(Dat[3:ncol(Dat[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat_perpop)){
tmp <- Dat_perpop[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
# Set the names of the matrices
row.names(q.freq)  <- names(Dat_perpop)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
p.freq <- as.matrix(1-q.freq)
View(q.freq)
# Combine allele frequency matrices
freq_comb <- cbind(q.freq, p.freq)
# Get the harmonic mean of the number of individuals per population
N.harm <- 1/mean(1/n.perpop)
1/N.harm
1/(1/N.harm)
mean(n.perpop)
# Set the results matrix
JD_res <- matrix(ncol = nrow(q.freq), nrow = nrow(q.freq))
rownames(JD_res) <- colnames(JD_res) <- row.names(q.freq)
# Get the comparisons
Comps <- combn(rownames(q.freq), m = 2)
n.pop <- as.numeric(n.pop)
as.numeric(length(Dat_perpop))
n.pop <- as.numeric(length(Dat_perpop))
# Within population measures
deltaS <- mean(1 - rowSums(freq_comb2))
Hs <- (2*N.harm/((2*N.harm)-1))*deltaS
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
D <- (Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
View(MMOD.D)
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
# Within population measures
deltaS <- mean(1 - rowSums(freq_comb2))
Hs <- (2*N.harm/((2*N.harm)-1))*deltaS
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
D <- (Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
(Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
# Within population measures
deltaS <- mean(1 - rowSums(freq_comb)^2)
Hs <- (2*N.harm/((2*N.harm)-1))*deltaS
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
(Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
# Combine allele frequency matrices
freq_comb <- cbind(q.freq, p.freq)
# Ht_est, Hs_est, and n go into Jost's D estimation
HpS <- mean(1 - rowSums(a^2))
Hs_est <- (2*harmN/(2*harmN-1))*HpS
HpT <- 1 - sum(colMeans(a)^2)
Ht_est <- HpT + Hs_est/(2*harmN*n)
D = (Ht_est-Hs_est)/(1-Hs_est) * (n/(n-1))
View(a)
View(p.freq)
View(q.freq)
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb2))
# Within population measures
deltaS <- mean(1 - rowSums(freq_comb2))
Hs <- (2*N.harm/((2*N.harm)-1))*deltaS
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
(Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
# Within population measures
deltaS <- mean(1 - rowSums(freq_comb^2))
Hs <- (2*N.harm/(2*N.harm-1))*deltaS
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
(Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
View(Mmod.dat)
View(MMOD.D)
1/(1/D)
D <- 1/(1/(Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1)))
D <- (Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
D <- 1/(1/D)
View(MMOD.D)
D <- (Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
D <- (Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
# Within population measures
deltaS <- mean(1 - rowSums(freq_comb^2))
Hs <- (2*N.harm/(2*N.harm-1))*deltaS
# Overall measures
deltaT <- 1 - sum(colMeans(freq_comb)^2)
Ht <- deltaT + Hs/(2*N.harm*n.pop)
D <- (Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
1/(1/D)
(Ht-Hs)/(1-Hs) * (n.pop/(n.pop-1))
(Ht_est-Hs_est)/(1-Hs_est) * (n/(n-1))
View(MMOD.D)
