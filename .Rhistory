p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
}
if(split.size==0){
split.size=npops #attempt split size the same as original p-matrix size --- may require computer with big memory
}
splits <- ceiling((npops*npops)/split.size) #number of 50mb splits to perform
pre.split <- 0
p.dup.ids <- (sort((rep(1:npops, npops)))) #duplication ids for p
m.dup.ids <- rep(1:npops, npops) #duplication ids for m
jxjy=NULL
if(split.size > 1){ #if split size is greater than 1, therefore p.dup will be a 2dim matrix
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
if(split.size > 1){ #if split size is greater than 1, therefore p.dup will be a 2dim matrix
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
if( length(((pre.split*split.size)+1):(npops*npops))>1 ){ #if final split size is >1 and therefore calculations are on a 2dim matrix
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}else{ #if final split size is 1 and therefore calculations are on a vector
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}
}else{ #if split size is 1, therefore p.dup and m.dup will be a vector, therefore rowSums do not work
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}
}
m <- matrix(1, nrow=dim(p)[1], ncol=dim(p)[2])
m[is.na(p)]=0 #matrix of true false (1/0) missing genotype of each ind & loci
p <- as.matrix(p)
p[is.na(p)]=0
tmp.x <- p
tmp.y <- (1-p)*m
jxy <- (tmp.x%*%t(tmp.x))+(tmp.y%*%t(tmp.y))
split.size <- ceiling((50/as.numeric(object.size(p)/1048576))*npops) #size of duplicated p matrix under 50mb
if(split.size==0){
split.size=npops #attempt split size the same as original p-matrix size --- may require computer with big memory
}
splits <- ceiling((npops*npops)/split.size) #number of 50mb splits to perform
pre.split <- 0
p.dup.ids <- (sort((rep(1:npops, npops)))) #duplication ids for p
m.dup.ids <- rep(1:npops, npops) #duplication ids for m
jxjy=NULL
if(split.size > 1){ #if split size is greater than 1, therefore p.dup will be a 2dim matrix
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
if(split.size > 1){ #if split size is greater than 1, therefore p.dup will be a 2dim matrix
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
if( length(((pre.split*split.size)+1):(npops*npops))>1 ){ #if final split size is >1 and therefore calculations are on a 2dim matrix
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}else{ #if final split size is 1 and therefore calculations are on a vector
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}
}else{ #if split size is 1, therefore p.dup and m.dup will be a vector, therefore rowSums do not work
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}
}
View(p.dup)
m <- matrix(1, nrow=dim(p)[1], ncol=dim(p)[2])
m[is.na(p)]=0 #matrix of true false (1/0) missing genotype of each ind & loci
p <- as.matrix(p)
p[is.na(p)]=0
View(p)
tmp.x <- p
tmp.y <- (1-p)*m
jxy <- (tmp.x%*%t(tmp.x))+(tmp.y%*%t(tmp.y))
View(jxy)
View(tmp.y)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
View(q.freq)
q2 <- q.freq^2
View(q2)
0.2941176^2
0.3428571^2
# Squared allele frequencies in populations
Jx <- rowSums(q2[,1])/r
# Squared allele frequencies in populations
Jx <- rowSums(q2[1,])/r
# Square the allele frequencies so that we can create Jx and Jy
q2 <- as.matrix(q.freq^2)
# Squared allele frequencies in populations
Jx <- rowSums(q2[1,])/r
q2 <- as.matrix(q.freq^2)
dim(q2)
# Squared allele frequencies in populations
Jx <- rowSums(q2[1])/r
# Squared allele frequencies in populations
Jx <- rowSums(q2)/r
# Squared allele frequencies in populations
Jx <- sum(q2[1,])/r
# Squqred allele frequencies in populations
Jy <- sum(q2[,2])/r
Jxy <- (Jx*Jy)/r
View(Stampp_ND)
ND <- -ln(Jxy/sqrt(Jx*Jy))
ND <- -log(Jxy/sqrt(Jx*Jy))
1/ND
sqJxy <- sqrt(Jx*Jy)
ND <- -log(Jxy/sqJxy)
i <- Jxy/sqJxy
i <- i/t(sqJxy)
-log(i)
# Squared allele frequencies in populations
Jx <- sum(q2[1,])/r
# Squqred allele frequencies in populations
Jy <- sum(q2[2,])/r
Jxy <- (Jx*Jy)/r
sqJxy <- sqrt(Jx*Jy)
ND <- -log(Jxy/sqJxy)
test <- q2[1,]/r
sum(test)
q2{1,]*q2[2,]
q2[1,]*q2[2,]
Jxy <- sum(q2[1,]*q2[2,])/r
sqJxy <- sqrt(Jx*Jy)
ND <- -log(Jxy/sqJxy)
1/ND
sum(q2[1,]*q2[2,])
sum(q2[1,]*q2[2,])/r
View(q.freq)
# Squared allele frequencies in populations
Jx <- q[1,]*q[2,]
# Squared allele frequencies in populations
Jx <- q.freq[1,]*q.freq[2,]
# Squared allele frequencies in populations
Jx <- sum(q.freq[1,]*q.freq[2,]) # sum(q2[1,])/r
# Squared allele frequencies in populations
Jx <- sum(q2[1,]/r)
# Squared allele frequencies in populations
Jy <- sum(q2[2,]/r)
Jxy <- sum(q2[1,]*q2[2,]/r
sqJxy <- sqrt(Jx*Jy)
Jxy <- sum(q2[1,]*q2[2,]/r)
sqJxy <- sqrt(Jx*Jy)
ND <- -log(Jxy/sqJxy)
Jxy <- sum(q.freq[1,]*q.freq[2,]/r)
sqJxy <- sqrt(Jx*Jy)
ND <- -log(Jxy/sqJxy)
i <- Jxy/sqJxy
i <- i/t(sqJxy)
-log(i)
i <- Jxy/sqJxy
Jy <- sum(q2[2,]/r)
Jy2 <- sum(q[2,]^2/r)
Jy2 <- sum((q.freq[2,]^2)/r)
Jx <- sum(q2[1,]/r)
# Squared allele frequencies in populations
Jy <- sum(q2[2,]/r)
Jxy <- sum(q.freq[1,]*q.freq[2,]/r)
sqJxy <- sqrt(Jx*Jy)
sqJxy <- sqrt(Jx*Jy)
N
ND <- -log(Jxy/sqJxy)
sqJxy <- sqrt(Jx%*%Jy)
sqJxy <- sqrt(Jx*Jy)
sqJxy <- sqrt(Jx%*%Jy)
ND <- -log(Jxy/sqJxy)
i <- Jxy/sqJxy
i <- i/t(sqJxy)
-log(i)
p.freq <- 1-q.freq
View(p.freq)
# Square the allele frequencies so that we can create Jx and Jy
p2 <- as.matrix(p.freq^2)
# r = number of loci
r <- ncol(p.freq)
# Squared allele frequencies in populations
Jx <- sum(p2[1,]/r)
# Squared allele frequencies in populations
Jy <- sum(p2[2,]/r)
Jxy <- sum(p.freq[1,]*p.freq[2,]/r)
sqJxy <- sqrt(Jx%*%Jy)
ND <- -log(Jxy/sqJxy)
i <- Jxy/sqJxy
i <- i/t(sqJxy)
ND <- -log(Jxy/sqJxy)
# Squared allele frequencies in populations
Jy <- sum(p2[2,]/r)
Jxy <- sum(p.freq[1,]*p.freq[2,]/r)
sqJxy <- sqrt(Jx%*%Jy)
ND <- -log(Jxy/sqJxy)
i <- Jxy/sqJxy
i <- i/t(sqJxy)
-log(i)
sum(p.freq[1,], p.freq[2,])
m <- matrix(1, nrow=dim(p)[1], ncol=dim(p)[2])
m[is.na(p)]=0 #matrix of true false (1/0) missing genotype of each ind & loci
p <- as.matrix(p)
p[is.na(p)]=0
tmp.x <- p
tmp.y <- (1-p)*m
View(tmp.y)
jxy <- (tmp.x%*%t(tmp.x))+(tmp.y%*%t(tmp.y))
split.size <- ceiling((50/as.numeric(object.size(p)/1048576))*npops) #size of duplicated p matrix under 50mb
if(split.size==0){
split.size=npops #attempt split size the same as original p-matrix size --- may require computer with big memory
}
splits <- ceiling((npops*npops)/split.size) #number of 50mb splits to perform
pre.split <- 0
p.dup.ids <- (sort((rep(1:npops, npops)))) #duplication ids for p
m.dup.ids <- rep(1:npops, npops) #duplication ids for m
View(p.dup)
jxjy=NULL
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
View(p.dup)
sum((p.dup*m.dup)
)
View(p.dup)
View(p)
(p.dup*m.dup)^2
sum((p.dup*m.dup)^2)
sum((p[1,])^2)
View(m.dup)
sum((p)^2)
sum((p.dup)^2)
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2))
sq.jxjy <- sqrt(matrix(jxjy, nrow=npops, ncol=npops)) #square root of the sum of squared allele freq
i <- jxy/sq.jxjy
i <- i/t(sq.jxjy) #normalised identity averaged across loci
d <- -log(i) #Nei's genetic distance
neis.d <- (matrix(as.numeric(sprintf("%.6f", d)), nrow=npops)) #summarise to six decimal places
View(neis.d)
row.names(neis.d)=pops
pops <- unique(pop.names) #population names
pop.num <- vector(length=length(geno[,1]))
m <- matrix(1, nrow=dim(p)[1], ncol=dim(p)[2])
m[is.na(p)]=0 #matrix of true false (1/0) missing genotype of each ind & loci
p <- as.matrix(p)
p[is.na(p)]=0
tmp.x <- p
tmp.y <- (1-p)*m
jxy <- (tmp.x%*%t(tmp.x))+(tmp.y%*%t(tmp.y))
split.size <- ceiling((50/as.numeric(object.size(p)/1048576))*npops) #size of duplicated p matrix under 50mb
if(split.size==0){
split.size=npops #attempt split size the same as original p-matrix size --- may require computer with big memory
}
splits <- ceiling((npops*npops)/split.size) #number of 50mb splits to perform
pre.split <- 0
p.dup.ids <- (sort((rep(1:npops, npops)))) #duplication ids for p
m.dup.ids <- rep(1:npops, npops) #duplication ids for m
jxjy=NULL
if(split.size > 1){ #if split size is greater than 1, therefore p.dup will be a 2dim matrix
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
if(split.size > 1){ #if split size is greater than 1, therefore p.dup will be a 2dim matrix
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
if( length(((pre.split*split.size)+1):(npops*npops))>1 ){ #if final split size is >1 and therefore calculations are on a 2dim matrix
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, rowSums((p.dup*m.dup)^2)+rowSums(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}else{ #if final split size is 1 and therefore calculations are on a vector
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}
}else{ #if split size is 1, therefore p.dup and m.dup will be a vector, therefore rowSums do not work
if(splits > 1){ #if dataset is too large and needs to be split
for(i in 1:(splits-1)){ #stepwise calculation of jxjy based on 50mb split chuncks
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(i*split.size)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(i*split.size)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
pre.split <- i
}
}
p.dup <- (p[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of allele frequencies to calculate squared allele freq, jx & jy
m.dup <- (m[m.dup.ids[((pre.split*split.size)+1):(npops*npops)],]) #matrix of true false (1/0) missing genotype of each ind & loci to adjust p.dup matrix for missing alleles
m.dup2 <- (m[p.dup.ids[((pre.split*split.size)+1):(npops*npops)],])
jxjy <- c(jxjy, sum((p.dup*m.dup)^2)+sum(((1-p.dup)*m.dup*m.dup2)^2)) #sum of square allele freq
}
sq.jxjy <- sqrt(matrix(jxjy, nrow=npops, ncol=npops)) #square root of the sum of squared allele freq
i <- jxy/sq.jxjy
i <- i/t(sq.jxjy) #normalised identity averaged across loci
d <- -log(i) #Nei's genetic distance
neis.d <- (matrix(as.numeric(sprintf("%.6f", d)), nrow=npops)) #summarise to six decimal places
row.names(neis.d)=pops
}
View(neis.d)
View(jxy)
View(sq.jxjy)
View(m.dup2)
MAT <- q[1:2,] %*% t(q[1:2,])
MAT <- q.freq[1:2,] %*% t(q.freq[1:2,])
View(MAT)
vec <- sqrt(diag(MAT))
MAT <- MAT/vec[col(MAT)]
MAT <- MAT/vec[row(MAT)]
-log(MAT)
Genind <- vcfR::vcfR2genind(HornedLizard_VCF)
Genind@pop <- as.factor(HornedLizard_Pop$Population)
MAT <- adegenet::makefreq(Genind)
View(Dat)
Poppr_ND <- neis.d(Genind)
Poppr_ND <- poppr::neis.d(Genind)
Poppr_ND <- poppr::nei.dist(Genind)
Poppr_ND
?nei.dist()
Stampp_ND_ind <- StAMPP::stamppNeisD(Glight, pop = F)
Stampp_ND_ind == Poppr_ND
View(MAT)
View(Dat)
# Calculate allele frequencies
freq <- matrix(nrow(length(Dat), ncol = length(Dat[3:ncol(Dat)])*2)
# Calculate population Nei's D
# Create a matrix to store the alternate allele frequency for each population
q.freq <- matrix(nrow = length(Dat), ncol = length(Dat[3:ncol(Dat[[1]])]))
freq <- matrix(nrow(length(Dat), ncol = length(Dat[3:ncol(Dat)])*2))
# Calculate allele frequencies
freq <- matrix(nrow = length(Dat), ncol = (length(Dat[3:ncol(Dat)])*2))
View(freq)
ncol(freq)
# Create a matrix to store the alternate allele frequency for each population
q.freq <- matrix(nrow = length(Dat), ncol = length(Dat[3:ncol(Dat[[1]])]))
# First we calculate allele frequencies of the alternate allele in each population
for(i in 1:length(Dat)){
tmp <- Dat[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
for(i in 1:length(Dat_perpop)){
tmp <- Dat_perpop[[i]]
# Get frequency of alternate alleles
q.freq[i,] <- (((colSums(tmp[3:ncol(tmp)] == 2, na.rm = T))*2) + colSums(tmp[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(tmp[3:ncol(tmp)] != "NA"))
}
View(q.freq)
# Set the names of the matrices
row.names(q.freq)  <- names(Dat)
# Set the names of the matrices
row.names(q.freq)  <- names(Dat_perpop)
# Make the allele frequencies a numeric matrix
q.freq <- as.matrix(q.freq)
p.freq <- as.matrix(1-q.freq)
View(MAT)
freq_comb <- cbind(q.freq, p.freq)
IDMAT2 <- freq_comb %*% t(freq_comb)
IDMAT <- MAT %*% t(MAT)
View(IDMAT2)
vec2 <- sqrt(diag(IDMAT2))
IDMAT2 <- IDMAT2/vec2[col(IDMAT2)]
IDMAT2 <- IDMAT2/vec2[row(IDMAT)]
IDMAT2 <- IDMAT2/vec2[row(IDMAT2)]
ND <- -log(IDMAT2)
Stamp_neisD <- StAMPP::stamppNeisD(Glight)
View(Stamp_neisD)
Stamp_neisD - ND
mean(Stamp_neisD - ND)
max(Stamp_neisD - ND)
freq_comb[1:2,] %*% t(freq_comb[1:2,])
View(freq_comb)
freq_comb[1:2,1:2] %*% t(freq_comb[1:2,1:2])
Test <- freq_comb[1:2,1:2]
Test_t <- t(freq_comb[1:2,1:2])
Test
Test_t
0.2941176*0.3428571
0.2941176^2
0.2941176^2 + 0.8823529^2
freq_comb2 <- freq_comb^2
View(freq_comb2)
freq_comb2 <- freq_comb^2/r
Jx <- freq_comb2[1,]
Jy <- freq_comb2[2,]
Jx <- wum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- sum(freq_comb[1,]*freq_comb2/r)
Jxy <- sum(freq_comb[1,]*freq_comb2[2,]/r)
D <- Jxy/(sqrt(Jx*Jy))
-ln(D)
-log(D)
sqrt(Jx*Jy)
col(IDMAT2)
row(IDMAT2)
freq_comb2 <- (freq_comb^2)/r
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- sum(freq_comb[1,]*freq_comb2[2,]/r)
D <- Jxy/(sqrt(Jx*Jy))
-log(D)
Jxy <- sum(freq_comb[1,]*freq_comb2[2,])/r
D <- Jxy/(sqrt(Jx*Jy))
-log(D)
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- sum(freq_comb[1,]*freq_comb2[2,])/r
D <- Jxy/(sqrt(Jx*Jy))
-log(D)
freq_comb2 <- freq_comb^2
Jx <- sum(freq_comb2[1,])/r
Jy <- sum(freq_comb2[2,])/r
Jxy <- sum(freq_comb[1,]*freq_comb2[2,])/r
D <- Jxy/(sqrt(Jx*Jy))
-log(D)
freq_comb2 <- freq_comb^2/r
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- freq_comb[1,]*freq_comb2[2,]/r
Jxy <- sum(Jxy)
r = 646
freq_comb2 <- freq_comb^2/r
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- freq_comb[1,]*freq_comb2[2,]/r
Jxy <- sum(Jxy)
D <- Jxy/(sqrt(Jx*Jy))
-log(D)
r = 343
freq_comb2 <- freq_comb^2/r
Jx <- sum(freq_comb2[1,])
Jy <- sum(freq_comb2[2,])
Jxy <- freq_comb[1,]*freq_comb[2,]/r
Jxy <- sum(Jxy)
D <- Jxy/(sqrt(Jx*Jy))
-log(D)
View(neis.d)
neis.d[1,2] - (-log(D))
