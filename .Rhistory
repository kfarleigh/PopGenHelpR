}
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
# Break into list with populations for each element
Dat_perpop <- list()
for(i in unique(P)){
Dat_perpop[[i]] <- Dat[which(Dat[,2] == i),]
}
message('Formatting has finished, moving onto calculations')
unlist(strsplit(Dat[,1], split = '/')))
unlist(strsplit(Dat[,1], split = '/'))
unlist(strsplit(Dat[,3], split = '/'))
seqs <- unlist(strsplit(Dat[,3:ncol(Dat)], split = '/'))
View(Dat)
seqs <- unlist(strsplit(Dat[,3], split = '/'))
seqs <- strsplit(Dat[,3], split = '/')
View(seqs)
seqs <- unlist(sapply(strsplit(Dat[,3:ncol(Dat)], split = '/')))
Test <- Dat[,3:ncol(Dat)]
Test2 <- apply(Test, 2, strsplit(Dat, split = "/"))
Test2 <- apply(Test, 2, strsplit(as.character(Dat), split = "/"))
Test2 <- apply(Test, 2, strsplit(split = "/"))
Test2 <- apply(Test, 2, strsplit(Dat,split = "/"))
Test2 <- apply(Test, 2, strsplit(Test,split = "/"))
Test <- as.character(Test)
Test2 <- apply(Test, 2, strsplit(Test,split = "/"))
Test <- Dat[,3:ncol(Dat)]
Alleles <- list()
for(i in 1:ncol(Test)){
tmp <- Test[,1]
tmp2 <- unlist(strsplit(tmp, split = '/'))
Alleles[[i]] <- tmp2
remove(tmp, tmp2)
}
View(Alleles)
Alleles <- list()
for(i in 1:ncol(Test)){
tmp <- Test[,i]
tmp2 <- unlist(strsplit(tmp, split = '/'))
Alleles[[i]] <- tmp2
remove(tmp, tmp2)
}
View(Alleles)
Alleles[[1]]
tmp2 <- unlist(strsplit(Test[,1] split = '/'))
tmp2 <- unlist(strsplit(Test[,1], split = '/'))
tmp2 <- as.data.frame(unlist(strsplit(Test[,1], split = '/')))
View(tmp2)
tmp2 <- (strsplit(Test[,1], split = '/'))
Test2 <- do.call(tmp2, rbind)
Test2 <- do.call(rbind, tmp2)
View(Test2)
Alleles <- list()
for(i in 1:ncol(Test)){
tmp <- Test[,i]
tmp2 <- strsplit(tmp, split = '/')
Alleles[[i]] <- do.call(rbind,tmp2)
remove(tmp, tmp2)
}
View(Alleles)
Alleles[[1]]
Seqs <- do.call(cbind, Alleles)
View(Seqs)
rownames(Seqs) <- rownames(Dat)
# Get pairwise comparisons
Comps <- combn(rownames(Seqs), m = 2)
View(Comps)
ncol(Comps)
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(Comps)
View(Difs)
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- t(as.data.frame(Comps))
Difs$Differences <- NA
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- t(as.data.frame(Comps))
Difs$Differences <- 0
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- t(as.data.frame(Comps))
View(Difs)
Difs$Differences <- 1
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(t(Comps))
Difs$Differences <- 1
View(Difs)
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(t(Comps))
Difs$Differences <- NA
View(Difs)
i = 1
Inds2comp <- Comps[,i]
Comp_tmp <- Seqs[which(rownames(Seqs) %in% Inds2comp),]
View(Comp_tmp)
idnetical(Comp_tmp[1,], Comp_tmp[2,])
table((Comp_tmp[1,] == Comp_tmp[2,]))
table((Comp_tmp[1,1:10] == Comp_tmp[2,1:10]))
tmp_res <- table((Comp_tmp[1,] == Comp_tmp[2,]))
tmp_res <- as.data.frame(table((Comp_tmp[1,] == Comp_tmp[2,])))
View(tmp_res)
Dif_col <- which(tmp_res[,1] == "FALSE")
View(tmp_res)
# Make sure that we select the right table entry
Dif_row <- which(tmp_res[,1] == "FALSE")
Difs <- tmp_res[Dif_row,2]
Difs <- as.numeric(tmp_res[Dif_row,2])
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(t(Comps))
Difs$Differences <- NA
# Perform each comparison
for(i in 1:ncol(Comps)){
Inds2comp <- Comps[,i]
Comp_tmp <- Seqs[which(rownames(Seqs) %in% Inds2comp),]
tmp_res <- as.data.frame(table((Comp_tmp[1,] == Comp_tmp[2,])))
# Make sure that we select the right table entry
Dif_row <- which(tmp_res[,1] == "FALSE")
PW_difs <- as.numeric(tmp_res[Dif_row,2])
# Store results
Difs[i,3] <- PW_difs
remove(Inds2comp, Comp_tmp, tmp_res, Dif_row, PW_difs)
}
View(Difs)
# Get pairwise comparisons
Comps <- combn(rownames(Seqs), m = 2)
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(t(Comps))
Difs$Differences <- NA
# Perform each comparison
for(i in 1:ncol(Comps)){
Inds2comp <- Comps[,i]
Comp_tmp <- Seqs[which(rownames(Seqs) %in% Inds2comp),]
tmp_res <- as.data.frame(table((Comp_tmp[1,] == Comp_tmp[2,])))
# Make sure that we select the right table entry
Dif_row <- which(tmp_res[,1] == "FALSE")
PW_difs <- as.numeric(tmp_res[Dif_row,2])
# Store results
if(PW_difs > 0){
Difs[i,3] <- PW_difs
} else{
Difs[i,3] <- 0
}
remove(Inds2comp, Comp_tmp, tmp_res, Dif_row, PW_difs)
}
# Get pairwise comparisons
Comps <- combn(rownames(Seqs), m = 2)
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(t(Comps))
Difs$Differences <- NA
# Perform each comparison
for(i in 1:ncol(Comps)){
Inds2comp <- Comps[,i]
Comp_tmp <- Seqs[which(rownames(Seqs) %in% Inds2comp),]
tmp_res <- as.data.frame(table((Comp_tmp[1,] == Comp_tmp[2,])))
# Make sure that we select the right table entry
Dif_row <- which(tmp_res[,1] == "FALSE")
PW_difs <- as.numeric(tmp_res[Dif_row,2])
# Store results
if(!is.empty(PW_difs)){
Difs[i,3] <- PW_difs
} else{
Difs[i,3] <- 0
}
remove(Inds2comp, Comp_tmp, tmp_res, Dif_row, PW_difs)
}
# Get pairwise comparisons
Comps <- combn(rownames(Seqs), m = 2)
# Determine how many differences there are per site per comparison
# Use the same structure as the Comps object
Difs <- as.data.frame(t(Comps))
Difs$Differences <- NA
# Perform each comparison
for(i in 1:ncol(Comps)){
Inds2comp <- Comps[,i]
Comp_tmp <- Seqs[which(rownames(Seqs) %in% Inds2comp),]
tmp_res <- as.data.frame(table((Comp_tmp[1,] == Comp_tmp[2,])))
# Make sure that we select the right table entry
Dif_row <- which(tmp_res[,1] == "FALSE")
PW_difs <- as.numeric(tmp_res[Dif_row,2])
# Store results
if(!rlang::is_empty(PW_difs)){
Difs[i,3] <- PW_difs
} else{
Difs[i,3] <- 0
}
remove(Inds2comp, Comp_tmp, tmp_res, Dif_row, PW_difs)
}
View(Difs)
summary(Difs)
Comp_tmp[1,] == Comp_tmp[2,]
i = 1
Inds2comp <- Comps[,i]
Comp_tmp <- Seqs[which(rownames(Seqs) %in% Inds2comp),]
Comp_tmp[1,] == Comp_tmp[2,]
Dat <- Dat_perpop[[1]]
View(Dat)
Dat.pop <- Dat[,2]
Dat.gen <- Dat[,3:ncol(Dat)]
rownames(Dat.gen) <- Dat[,1]
# Seperate alleles and create sequences for each individual
Alleles <- list()
for(i in 1:ncol(Dat.gen)){
tmp <- Dat.gen[,i]
tmp2 <- strsplit(tmp, split = '/')
Alleles[[i]] <- do.call(rbind,tmp2)
remove(tmp, tmp2)
}
Seqs <- do.call(cbind, Alleles)
rownames(Seqs) <- rownames(Dat.gen)
View(Alleles)
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds_popmap <- Pops[,1]
} else if(!is.null(individual_col)){
Inds_popmap <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq <- vcfR::extract.gt(Dat)
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq <- vcfR::extract.gt(Dat)
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else {
stop("Please supply a vcf file or vcfR object for analysis")
}
P <- Pops
data <- HornedLizard_VCF
pops <- HornedLizard_Pop
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds_popmap <- Pops[,1]
} else if(!is.null(individual_col)){
Inds_popmap <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq <- vcfR::extract.gt(Dat)
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq <- vcfR::extract.gt(Dat)
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else {
stop("Please supply a vcf file or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != Inds_popmap)){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != Inds_popmap)], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
Dat_frq <- cbind.data.frame(Inds, P, Dat_frq)
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds_popmap <- Pops[,1]
} else if(!is.null(individual_col)){
Inds_popmap <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
gt_freq <- vcfR::extract.gt(Dat)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
gt_freq <- vcfR::extract.gt(Dat)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else {
stop("Please supply a vcf file or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != Inds_popmap)){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != Inds_popmap)], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
Dat_frq <- cbind.data.frame(Inds, P, Dat_frq)
View(Dat_frq)
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds_popmap <- Pops[,1]
} else if(!is.null(individual_col)){
Inds_popmap <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
gt_freq <- vcfR::extract.gt(Dat)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt_freq == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt_freq)))
# Preserve individual names
Inds <- rownames(Dat)
} else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
gt_freq <- vcfR::extract.gt(Dat)
Dat <- as.data.frame(t(as.matrix(gt)))
gt_freq[gt_freq == "0/0"] <- 0
gt_freq[gt_freq == "0/1" | gt_freq == "1/0"] <- 1
gt_freq[gt_freq == "1/1"] <- 2
Dat_frq <- as.data.frame(t(as.matrix(gt_freq)))
# Preserve individual names
Inds <- rownames(Dat)
} else {
stop("Please supply a vcf file or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != Inds_popmap)){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != Inds_popmap)], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
Dat_frq <- cbind.data.frame(Inds, P, Dat_frq)
View(Dat_frq)
Dat_perpop_frq <- list()
for(i in unique(P)){
Dat_perpop_frq[[i]] <- Dat_frq[which(Dat_frq[,2] == i),]
}
message('Formatting has finished, moving onto calculations')
View(Dat_perpop_frq)
Dat_frq <- Dat_perpop_frq[[1]]
q.freq[1,] <- (((colSums(Dat_frq[3:ncol(Dat_frq)] == 2, na.rm = T))*2) + colSums(Dat_frq[3:ncol(tmp)] == 1, na.rm = T))/(2*colSums(Dat_frq[3:ncol(Dat_frq)] != "NA"))
q.freq[1,] <- (((colSums(Dat_frq[3:ncol(Dat_frq)] == 2, na.rm = T))*2) + colSums(Dat_frq[3:ncol(Dat_frq)] == 1, na.rm = T))/(2*colSums(Dat_frq[3:ncol(Dat_frq)] != "NA"))
### Calculate nucleotide diversity (pi)
## Get allele frequencies
nloc <- ncol(3:ncol(Dat_frq))
### Calculate nucleotide diversity (pi)
## Get allele frequencies
nloc <- length(3:ncol(Dat_frq))
q.freq <- matrix(nrow = 1, ncol = nloc)
q.freq[1,] <- (((colSums(Dat_frq[3:ncol(Dat_frq)] == 2, na.rm = T))*2) + colSums(Dat_frq[3:ncol(Dat_frq)] == 1, na.rm = T))/(2*colSums(Dat_frq[3:ncol(Dat_frq)] != "NA"))
p.freq <- 1-q.freq
pq <- q.freq*p.freq
View(pq)
Difs$Prop <- Difs$Differences/nloc
View(Difs)
table(3:ncol(Dat_frq))
colSums(3:ncol(Dat_frq)) == 2
colSums(Dat_frq[3:ncol(Dat_frq)] == 2)
q.count <- ((colSums(Dat_frq[3:ncol(Dat_frq)] == 2, na.rm = T))*2) + colSums(Dat_frq[3:ncol(Dat_frq)] == 1, na.rm = T))
q.count <- (((colSums(Dat_frq[3:ncol(Dat_frq)] == 2, na.rm = T))*2) + colSums(Dat_frq[3:ncol(Dat_frq)] == 1, na.rm = T))
p.count <- (((colSums(Dat_frq[3:ncol(Dat_frq)] == 0, na.rm = T))*2) + colSums(Dat_frq[3:ncol(Dat_frq)] == 1, na.rm = T))
sum(q.count)
NA.count <- (2*colSums(Dat_frq[3:ncol(Dat_frq)] == "NA"))
sum(NA.count)
q.freq <- sum(q.count)/nloc
p.freq <- sum(p.count)/nloc
q.freq <- sum(q.count)/(nloc*2)
p.freq <- sum(p.count)/(nloc*2)
colSums(Dat_frq[3:ncol(Dat_frq)] != "NA")
q.freq <- matrix(nrow = 1, ncol = nloc)
q.freq[1,] <- (((colSums(Dat_frq[3:ncol(Dat_frq)] == 2, na.rm = T))*2) + colSums(Dat_frq[3:ncol(Dat_frq)] == 1, na.rm = T))/(2*colSums(Dat_frq[3:ncol(Dat_frq)] != "NA"))
p.freq <- 1-q.freq
p.freq.bar <- mean(p.freq)
q.freq.bar <- mean(q.freq)
Difs$Prop.Pq <- Difs$Prop*(p.freq.bar*q.freq.bar)
View(Difs)
Nucdiv <- sum(Difs$Prop.Pq)
nind <- nrow(Dat_frq)
Test <- vcfR::vcfR2DNAbin(HornedLizard_VCF)
ND_test <- pegas::nuc.div(Test)
