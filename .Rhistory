}
if(rlang::is_empty(PA)){
PA_test[[i]] <- list()
} else{
PA_test[[i]] <- PA
}
print(paste("Finished private allele calculations for ", P_uniq[i], sep = ""))
}
names(PA_test) <- P_uniq
for(i in 1:length(PA_test)) {
if(length(PA_test[[i]]) > 0){
PA_test[[i]] <- do.call('rbind', PA_test[[i]])
} else{
PA_test[[i]] <- data.frame(Allele = character(), Locus = character())
}
}
# Count the number of private alleles in each population
PA_count <- list()
for(i in 1:length(PA_test)) {
PA_count[[i]] <- nrow(PA_test[[i]])
}
names(PA_count) <- names(PA_test)
PA_count <- do.call("rbind", PA_count)
PA_count <- as.data.frame(PA_count)
PA_count$Standard.deviation <- sd(PA_count[,1])
colnames(PA_count) <- c("Number.Private.Alleles", "Standard.deviation")
if(write == TRUE && !is.null(prefix)){
PA_test2 <- mapply(cbind, PA_test, "Pop"=names(PA_perpop), SIMPLIFY=F)
PA_mdata <- do.call("rbind", PA_test2)
write.csv(PA_mdata, paste(prefix, "PrivateAlleles_metadata.csv", sep = '_'), row.names = F)
write.csv(PA_count, paste(prefix, "PrivateAlleles_countperpop.csv", sep = '_'), row.names = F)
} else if(write == TRUE && is.null(prefix)) {
PA_test2 <- mapply(cbind, PA_test, "Pop"=names(PA_perpop), SIMPLIFY=F)
PA_mdata <- do.call("rbind", PA_test2)
write.csv(PA_mdata, "PrivateAlleles_metadata.csv", row.names = F)
write.csv(PA_count, "PrivateAlleles_countperpop.csv", row.names = F)
}
Final_res <- list(PA_count, PA_test)
names(Final_res) <- c("Private.Allele.Count", "Private.Allele.Metadata")
return(Final_res)
}
Test <- Private.alleles(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)
?vcfR::extract.gt
#' @param population_col Numeric. Optional argument (a number) indicating the column that contains the population assignment information.
#' @param individual_col Numeric. Optional argument (a number) indicating the column that contains the individuals (i.e., sample name) in the data.
#' @return A list containing the count of private alleles in each population and the metadata for those alleles. The metadata is a list that contains the private allele and locus name for each population.
#' @export
#'
#' @examples
#' \donttest{
#' data("HornedLizard_Pop")
#' data("HornedLizard_VCF")
#' Test <- Private.alleles(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)}
Private.alleles <- function(data, pops, write = FALSE, prefix = NULL, population_col = NULL, individual_col = NULL) {
Pop <- Standard.Deviation <- NULL
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds <- Pops[,1]
} else if(!is.null(individual_col)){
Inds <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
}
else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat, return.alleles = TRUE)
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
} else {
stop("Please supply a vcf file or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != P[,1])){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != P[,1])], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
# Break into list with populations for each element
Dat_perpop <- list()
for(i in unique(P)){
Dat_perpop[[i]] <- Dat[which(Dat[,2] == i),]
}
message('Formatting has finished, moving onto calculations')
#######################################
##### Private allele calculations #####
#######################################
Uniq_alleles <- function(x) {
tmp_res <- list()
for(i in 3:ncol(x)){
tmp <- unique(unlist(strsplit(x[,i], split = '/')))
tmp_res[[i]] <- tmp
remove(tmp)
}
tmp_res <- as.data.frame(do.call("rbind", tmp_res))
rownames(tmp_res) <- colnames(x[3:ncol(x)])
return(tmp_res)
}
PA_perpop <- lapply(Dat_perpop, Uniq_alleles)
PA_perpop <- mapply(cbind, PA_perpop, "Pop"=names(PA_perpop), SIMPLIFY=F)
PA_test_df <- do.call("rbind", PA_perpop)
PA_test_df$loc <- gsub('^.*\\.', "", rownames(PA_test_df))
# Get locus names
locnames <- unique(PA_test_df$loc)
P_uniq <- unique(P)
PA_test <- list()
for(i in 1:length(P_uniq)){
PA <- list()
for(j in 1:length(locnames)){
# Isolate test population
P_test <- PA_test_df[which(PA_test_df$Pop == P_uniq[i]),]
# Isolate remaining populations
Rem_pop <- PA_test_df[-c(which(PA_test_df$Pop == P_uniq[i])),]
# For each allele, find any alleles that are in the population P_test but not the remaining populations (Rem_pop)
Al_11 <- suppressMessages(dplyr::anti_join(P_test[which(P_test$loc == locnames[j]),c(1,4)], Rem_pop[which(Rem_pop$loc == locnames[j]),c(1,4)]))
Al_22 <- suppressMessages(dplyr::anti_join(P_test[which(P_test$loc == locnames[j]),c(2,4)], Rem_pop[which(Rem_pop$loc == locnames[j]),c(2,4)]))
Al_21 <- suppressMessages(dplyr::anti_join(P_test[which(P_test$loc == locnames[j]),c(2,4)], Rem_pop[which(Rem_pop$loc == locnames[j]),c(1,4)], by = join_by(V2 == V1, loc)))
Al_12 <- suppressMessages(dplyr::anti_join(P_test[which(P_test$loc == locnames[j]),c(1,4)], Rem_pop[which(Rem_pop$loc == locnames[j]),c(2,4)], by = join_by(V1 == V2, loc)))
# Check for cross comparisons, set to be empty if either allele was erroneously identified as private
# For example if we have A/G in P_test and G/A in Rem_pop; Al_11 and Al_22 would identify them as private because A != G and G !=A
# But they are indeed not private
if(nrow(Al_12) == 0 | nrow(Al_11) == 0){
Al_11 <- Al_12 <- data.frame(Allele = character(), Locus = character())
}
if(nrow(Al_21) == 0 | nrow(Al_22) == 0){
Al_22 <- Al_21 <- data.frame(Allele = character(), Locus = character())
}
colnames(Al_11) <- colnames(Al_22) <- colnames(Al_21) <- colnames(Al_12) <-c('Allele', "Locus")
PA_df <- rbind(Al_11, Al_22, Al_21, Al_12)
# Only keep unique private alleles
PA_df <- PA_df %>% distinct()
if(nrow(PA_df) != 0){
PA[[j]] <- PA_df
}
}
if(rlang::is_empty(PA)){
PA_test[[i]] <- list()
} else{
PA_test[[i]] <- PA
}
print(paste("Finished private allele calculations for ", P_uniq[i], sep = ""))
}
names(PA_test) <- P_uniq
for(i in 1:length(PA_test)) {
if(length(PA_test[[i]]) > 0){
PA_test[[i]] <- do.call('rbind', PA_test[[i]])
} else{
PA_test[[i]] <- data.frame(Allele = character(), Locus = character())
}
}
# Count the number of private alleles in each population
PA_count <- list()
for(i in 1:length(PA_test)) {
PA_count[[i]] <- nrow(PA_test[[i]])
}
names(PA_count) <- names(PA_test)
PA_count <- do.call("rbind", PA_count)
PA_count <- as.data.frame(PA_count)
PA_count$Standard.deviation <- sd(PA_count[,1])
colnames(PA_count) <- c("Number.Private.Alleles", "Standard.deviation")
if(write == TRUE && !is.null(prefix)){
PA_test2 <- mapply(cbind, PA_test, "Pop"=names(PA_perpop), SIMPLIFY=F)
PA_mdata <- do.call("rbind", PA_test2)
write.csv(PA_mdata, paste(prefix, "PrivateAlleles_metadata.csv", sep = '_'), row.names = F)
write.csv(PA_count, paste(prefix, "PrivateAlleles_countperpop.csv", sep = '_'), row.names = F)
} else if(write == TRUE && is.null(prefix)) {
PA_test2 <- mapply(cbind, PA_test, "Pop"=names(PA_perpop), SIMPLIFY=F)
PA_mdata <- do.call("rbind", PA_test2)
write.csv(PA_mdata, "PrivateAlleles_metadata.csv", row.names = F)
write.csv(PA_count, "PrivateAlleles_countperpop.csv", row.names = F)
}
Final_res <- list(PA_count, PA_test)
names(Final_res) <- c("Private.Allele.Count", "Private.Allele.Metadata")
return(Final_res)
}
Test <- Private.alleles(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)
View(Test)
HornedLizard_Pop2 <- HornedLizard_Pop$Sample[1] <- 'Ind1'
Test2 <- Private.alleles(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)
View(Test2)
Test2 <- Private.alleles(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE, individual_col = 1, population_col = 2)
library(devtools)
document()
document()
document()
library(devtools)
document()
document()
?.Deprecated
#'
#' @return A list containing the estimated diversity statistics, model output from linear regression of these statistics against latitude, and model plots.
#' @export
#'
#' @examples
#' \donttest{
#' data("HornedLizard_Pop")
#' data("HornedLizard_VCF")
#' Test <- Div_stats(VCF = HornedLizard_VCF, pops = HornedLizard_Pop,
#' ploidy = 2, write = FALSE)}
Div_stats <- function(VCF, pops, ploidy, write = FALSE, prefix) {
.Deprecated("Heterozygosity", msg = "The Div_Stats function has been deprecated as of PopGenHelpR v1.3.0 and will dissappear in v2.0.0.
Please use the Heterozygosity function if you wish to estimate heterozygosity or the Private.alleles function if you wish to calculate
the number of private alleles per population. Please use the Point_Map function if you wish to visualize the results on a map or plot.")
Latitude <- Heterozygosity <- Pop <- Standard.Deviation <- Private.Alleles <- NULL
# Read in files and convert to necessary formats
if(missing(VCF)){
stop("Please supply a vcf file for analysis")
}
if(methods::is(VCF,"vcfR")){
Dat <- VCF
Glight <- vcfR::vcfR2genlight(Dat)
}
else if(is.character(VCF)) {
Dat <- vcfR::read.vcfR(VCF, verbose = FALSE)
Glight <- vcfR::vcfR2genlight(Dat)
}
else{
stop("Please supply a vcf file or object of class vcfR for analysis")
}
# Set the ploidy of the genlight
adegenet::ploidy(Glight) <- ploidy
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(is.data.frame(pops)){
Pops <- pops
}
else if(is.character(pops)){
Pops <- utils::read.csv(pops)
}
else{
stop("Please supply a csv file or data frame for population assignment")
}
P <- Pops
if(any(Glight@ind.names %in% P[,1] == FALSE)){
stop("Sample names in the VCF and Population file are not in the same order or samples are missing,
The sample(s) in question are: ",
paste(Glight@ind.names[!(Glight@ind.names %in% P[,1])], collapse = ' '))  }
# Set the populations in the genlight
Pops <- as.factor(Pops[,2])
Glight@pop <- Pops
# Make an genind object and convert to format for heterozygosity calculations
Genind <- dartR::gl2gi(Glight, v = 0)
Hstat <- hierfstat::genind2hierfstat(Genind)
message('Formatting has finished, moving onto calculations')
##########################
##### Heterozygosity #####
##########################
# Calculate heterozygosity and standard deviation for each population
Het <- hierfstat::basic.stats(Hstat)
# Get per populations heterozygosity
H_all <- data.frame(colMeans(Het$Ho, na.rm = TRUE))
H_all$Pop <- rownames(H_all)
colnames(H_all) <- c('Heterozygosity', 'Pop')
# Standard deviation
H_all$StandardDeviation <- stats::sd(H_all$Heterozygosity)
# Attach coordinates
# First we check to make sure that the populations are in the right order
if(any(H_all$Pop != unique(P[,2]))){
stop("Populations are not in the correct order, if you see this please email the package authors")
}
# Pull populations coordinates
Pop_coords <- P[!duplicated(P$Population),]
# Append to heterozygosity estimates
H_all[,4:5] <- Pop_coords[,3:4]
colnames(H_all) <- c('Heterozygosity', 'Pop', 'Standard.Deviation','Longitude', 'Latitude')
# Is there a statistical relationship between heterozygosity and latitude
Het_model <- stats::lm(H_all$Heterozygosity ~ H_all$Latitude)
message('Heterozygosity calculated, moving to private alleles')
###########################
##### Private Alleles #####
###########################
# Get private alleles per population
Private_alleles <- data.frame(rowSums(poppr::private_alleles(Genind)))
Private_alleles$Pop <- rownames(Private_alleles)
colnames(Private_alleles) <- c('PrivateAlleles', 'Pop')
# Attach coordinates
# First we check to make sure that the populations are in the right order
if(any(Private_alleles$Pop != unique(P[,2]))){
stop("Populations are not in the correct order, if you see this please email the package authors")
}
Private_alleles[,3:4] <- Pop_coords[,3:4]
colnames(Private_alleles) <- c('Private.Alleles', 'Pop','Longitude', 'Latitude')
# Is there a statistical relationship between the number of private alleles and latitude
PA_model <- stats::lm(Private_alleles$Private.Alleles ~ Private_alleles$Latitude)
message('Private Alleles have been calculated, moving onto plotting')
##########################
##### Visualizations #####
##########################
##### Heterozygosity #####
# We will make a plot of heterozygostiy estimates and an interpolated map of heterozygosity values for each population
# Plot of heterozygosity values (y-axis) and latitude (x-axis)
Het_plot <- ggplot2::ggplot(data = H_all, ggplot2::aes(x = Latitude, y = Heterozygosity)) + ggplot2::geom_point(ggplot2::aes(color = Pop),size = 3) +
ggplot2::geom_errorbar(data = H_all, ggplot2::aes(x = Latitude, ymin = Heterozygosity-Standard.Deviation, ymax = Heterozygosity+Standard.Deviation,
color = Pop)) +
ggplot2::stat_smooth(method = 'lm', formula = y ~ x, size =1, colour = 'black') +
ggplot2::labs(x = 'Latitude', y = 'Heterozygosity') +
ggplot2::ggtitle(expression(atop("Obersved Heterozygosity of Localities"))) +
ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5),
legend.title = ggplot2::element_blank())
##### Private Alleles #####
# Plot of private allele values (y-axis) and latitude (x-axis)
Paf_plot <- ggplot2::ggplot(data = Private_alleles, ggplot2::aes(x = Latitude, y = Private.Alleles)) + ggplot2::geom_point(ggplot2::aes(color = Pop), size = 3) +
ggplot2::stat_smooth(method = 'lm', formula = y ~ x, size =1, colour = 'black') +
ggplot2::labs(x = 'Latitude', y = 'Private Alleles') +
ggplot2::ggtitle(expression(atop("Private Alleles of Localities"))) +
ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5),
legend.title = ggplot2::element_blank())
Output <- list(H_all, Private_alleles, Het_model, PA_model, Het_plot, Paf_plot)
names(Output) <- c('Heterozygosity_calculations', 'Private_Allele_Calculations', "Heterozygosity_vs_Latitude_Model",
"Private_Allleles_vs_Latitude_Model", "Heterozygosity_vs_Latitude_plot",
"PA_vs_Latitude_plot")
if(write == TRUE){
# Write out heterozygosity results
utils::write.csv(H_all, file = paste(as.character(prefix), '_Heterozygosity.csv', sep = ''), row.names = FALSE)
summary(Het_model)
# Write out linear regression results heterozygosity ~ latitude
sink(paste(as.character(prefix), '_Heterozygosity_lm.txt', sep = ''))
summary(Het_model)
sink()
# Write out private allele results
utils::write.csv(Private_alleles, file = paste(as.character(prefix), '_PrivateAlleles.csv', sep = ''), row.names = FALSE)
# Write out linear regression results private alleles ~ latitude
summary(PA_model)
sink(paste(as.character(prefix), '_Private.Alleles_lm.txt', sep = ''))
summary(PA_model)
sink()
}
message("Calculations have finished, the packages used to perform file formatting and calculations were
vcfR, adegenet, and dartR for formatting, hierfstat to calculate heterozygosity, and poppr to calculate private alleles")
return(Output)
}
Test <- Div_stats(VCF = HornedLizard_VCF, pops = HornedLizard_Pop,
#' ploidy = 2, write = FALSE)
)
Test <- Div_stats(VCF = HornedLizard_VCF, pops = HornedLizard_Pop, ploidy = 2, write = FALSE)
#'
#' @return A list containing the estimated diversity statistics, model output from linear regression of these statistics against latitude, and model plots.
#' @export
#'
#' @examples
#' \donttest{
#' data("HornedLizard_Pop")
#' data("HornedLizard_VCF")
#' Test <- Div_stats(VCF = HornedLizard_VCF, pops = HornedLizard_Pop,
#' ploidy = 2, write = FALSE)}
Div_stats <- function(VCF, pops, ploidy, write = FALSE, prefix) {
.Deprecated("Heterozygosity", msg = "The Div_Stats function has been deprecated as of PopGenHelpR v1.3.0 and will dissappear in v2.0.0. Please use the Heterozygosity function if you wish to estimate heterozygosity or the Private.alleles function if you wish to calculate the number of private alleles per population. Please use the Point_Map function if you wish to visualize the results on a map or plot.")
Latitude <- Heterozygosity <- Pop <- Standard.Deviation <- Private.Alleles <- NULL
# Read in files and convert to necessary formats
if(missing(VCF)){
stop("Please supply a vcf file for analysis")
}
if(methods::is(VCF,"vcfR")){
Dat <- VCF
Glight <- vcfR::vcfR2genlight(Dat)
}
else if(is.character(VCF)) {
Dat <- vcfR::read.vcfR(VCF, verbose = FALSE)
Glight <- vcfR::vcfR2genlight(Dat)
}
else{
stop("Please supply a vcf file or object of class vcfR for analysis")
}
# Set the ploidy of the genlight
adegenet::ploidy(Glight) <- ploidy
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(is.data.frame(pops)){
Pops <- pops
}
else if(is.character(pops)){
Pops <- utils::read.csv(pops)
}
else{
stop("Please supply a csv file or data frame for population assignment")
}
P <- Pops
if(any(Glight@ind.names %in% P[,1] == FALSE)){
stop("Sample names in the VCF and Population file are not in the same order or samples are missing,
The sample(s) in question are: ",
paste(Glight@ind.names[!(Glight@ind.names %in% P[,1])], collapse = ' '))  }
# Set the populations in the genlight
Pops <- as.factor(Pops[,2])
Glight@pop <- Pops
# Make an genind object and convert to format for heterozygosity calculations
Genind <- dartR::gl2gi(Glight, v = 0)
Hstat <- hierfstat::genind2hierfstat(Genind)
message('Formatting has finished, moving onto calculations')
##########################
##### Heterozygosity #####
##########################
# Calculate heterozygosity and standard deviation for each population
Het <- hierfstat::basic.stats(Hstat)
# Get per populations heterozygosity
H_all <- data.frame(colMeans(Het$Ho, na.rm = TRUE))
H_all$Pop <- rownames(H_all)
colnames(H_all) <- c('Heterozygosity', 'Pop')
# Standard deviation
H_all$StandardDeviation <- stats::sd(H_all$Heterozygosity)
# Attach coordinates
# First we check to make sure that the populations are in the right order
if(any(H_all$Pop != unique(P[,2]))){
stop("Populations are not in the correct order, if you see this please email the package authors")
}
# Pull populations coordinates
Pop_coords <- P[!duplicated(P$Population),]
# Append to heterozygosity estimates
H_all[,4:5] <- Pop_coords[,3:4]
colnames(H_all) <- c('Heterozygosity', 'Pop', 'Standard.Deviation','Longitude', 'Latitude')
# Is there a statistical relationship between heterozygosity and latitude
Het_model <- stats::lm(H_all$Heterozygosity ~ H_all$Latitude)
message('Heterozygosity calculated, moving to private alleles')
###########################
##### Private Alleles #####
###########################
# Get private alleles per population
Private_alleles <- data.frame(rowSums(poppr::private_alleles(Genind)))
Private_alleles$Pop <- rownames(Private_alleles)
colnames(Private_alleles) <- c('PrivateAlleles', 'Pop')
# Attach coordinates
# First we check to make sure that the populations are in the right order
if(any(Private_alleles$Pop != unique(P[,2]))){
stop("Populations are not in the correct order, if you see this please email the package authors")
}
Private_alleles[,3:4] <- Pop_coords[,3:4]
colnames(Private_alleles) <- c('Private.Alleles', 'Pop','Longitude', 'Latitude')
# Is there a statistical relationship between the number of private alleles and latitude
PA_model <- stats::lm(Private_alleles$Private.Alleles ~ Private_alleles$Latitude)
message('Private Alleles have been calculated, moving onto plotting')
##########################
##### Visualizations #####
##########################
##### Heterozygosity #####
# We will make a plot of heterozygostiy estimates and an interpolated map of heterozygosity values for each population
# Plot of heterozygosity values (y-axis) and latitude (x-axis)
Het_plot <- ggplot2::ggplot(data = H_all, ggplot2::aes(x = Latitude, y = Heterozygosity)) + ggplot2::geom_point(ggplot2::aes(color = Pop),size = 3) +
ggplot2::geom_errorbar(data = H_all, ggplot2::aes(x = Latitude, ymin = Heterozygosity-Standard.Deviation, ymax = Heterozygosity+Standard.Deviation,
color = Pop)) +
ggplot2::stat_smooth(method = 'lm', formula = y ~ x, size =1, colour = 'black') +
ggplot2::labs(x = 'Latitude', y = 'Heterozygosity') +
ggplot2::ggtitle(expression(atop("Obersved Heterozygosity of Localities"))) +
ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5),
legend.title = ggplot2::element_blank())
##### Private Alleles #####
# Plot of private allele values (y-axis) and latitude (x-axis)
Paf_plot <- ggplot2::ggplot(data = Private_alleles, ggplot2::aes(x = Latitude, y = Private.Alleles)) + ggplot2::geom_point(ggplot2::aes(color = Pop), size = 3) +
ggplot2::stat_smooth(method = 'lm', formula = y ~ x, size =1, colour = 'black') +
ggplot2::labs(x = 'Latitude', y = 'Private Alleles') +
ggplot2::ggtitle(expression(atop("Private Alleles of Localities"))) +
ggplot2::theme_classic() + ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5),
legend.title = ggplot2::element_blank())
Output <- list(H_all, Private_alleles, Het_model, PA_model, Het_plot, Paf_plot)
names(Output) <- c('Heterozygosity_calculations', 'Private_Allele_Calculations', "Heterozygosity_vs_Latitude_Model",
"Private_Allleles_vs_Latitude_Model", "Heterozygosity_vs_Latitude_plot",
"PA_vs_Latitude_plot")
if(write == TRUE){
# Write out heterozygosity results
utils::write.csv(H_all, file = paste(as.character(prefix), '_Heterozygosity.csv', sep = ''), row.names = FALSE)
summary(Het_model)
# Write out linear regression results heterozygosity ~ latitude
sink(paste(as.character(prefix), '_Heterozygosity_lm.txt', sep = ''))
summary(Het_model)
sink()
# Write out private allele results
utils::write.csv(Private_alleles, file = paste(as.character(prefix), '_PrivateAlleles.csv', sep = ''), row.names = FALSE)
# Write out linear regression results private alleles ~ latitude
summary(PA_model)
sink(paste(as.character(prefix), '_Private.Alleles_lm.txt', sep = ''))
summary(PA_model)
sink()
}
message("Calculations have finished, the packages used to perform file formatting and calculations were
vcfR, adegenet, and dartR for formatting, hierfstat to calculate heterozygosity, and poppr to calculate private alleles")
return(Output)
}
Test <- Div_stats(VCF = HornedLizard_VCF, pops = HornedLizard_Pop, ploidy = 2, write = FALSE)
document()
document()
document()
check()
document()
check()
