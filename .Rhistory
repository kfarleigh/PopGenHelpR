PropHt_res_perind <- t(as.data.frame(do.call("cbind", PropHt_res_perind)))
PropHt_res_perind[,1] <- as.numeric(PropHt_res_perind[,1])
PropHt_res_perind[,1] <- as.numeric(PropHt_res_perind[,1])
PropHt_res_perind[,1] <- as.numeric(as.data.frame(PropHt_res_perind[,1]))
PropHt_res_perind <- lapply(Dat_perpop, PropHt)
PropHt_res_perind <- mapply(rbind, PropHt_res_perind, "Pop"=names(PropHt_res_perind), SIMPLIFY=F)
PropHt_res_perind <- lapply(Dat_perpop, PropHt)
PropHt_res_perind <- mapply(rbind, PropHt_res_perind, "Pop"=names(PropHt_res_perind), SIMPLIFY=F)
View(PropHt_res_perind)
# Make it into a dataframe so that it is easier for users to view
PropHt_res_perind <- t(as.data.frame(do.call("cbind", PropHt_res_perind)))
PropHt_res_perind <- as.data.frame(PropHt_res_perind)
PropHt_res_perind[,1] <- as.numeric(PropHt_res_perind[,1])
StHe_res_perind <- lapply(Dat_perpop, StHe)
StHe_res_perind <- mapply(rbind, StHe_res_perind, "Pop"=names(StHe_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHe_res_perind <- t(as.data.frame(do.call("cbind", StHe_res_perind)))
StHe_res_perind <- as.data.frame(StHe_res_perind)
StHe_res_perind[,1] <- as.numeric(StHe_res_perind[,1])
View(StHe_res_perind)
# Estimate standardized heterozygosity based on the expected heterozygosity
StHe <- function(Dat){
St_He <- PropHt(Dat)/mean(ExpHe(Dat))
rownames(St_He) <- 'StHe'
return(St_He)
}
StHe_res_perind <- lapply(Dat_perpop, StHe)
StHe_res_perind <- mapply(rbind, StHe_res_perind, "Pop"=names(StHe_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHe_res_perind <- t(as.data.frame(do.call("cbind", StHe_res_perind)))
StHe_res_perind <- as.data.frame(StHe_res_perind)
StHe_res_perind[,1] <- as.numeric(StHe_res_perind[,1])
View(StHe_res_perind)
StHo_res_perind <- lapply(Dat_perpop, StHo)
StHo_res_perind <- mapply(rbind, StHo_res_perind, "Pop"=names(StHo_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHo_res_perind <- t(as.data.frame(do.call("cbind", StHo_res_perind)))
StHo_res_perind <- as.data.frame(StHo_res_perind)
StHo_res_perind[,1] <- as.numeric(StHo_res_perind[,1])
View(StHo_res_perind)
# Estimate standardized heterozygosity based on the observed heterozyosity
StHo <- function(Dat){
St_Ho <- PropHt(Dat)/mean(ObsHet(Dat))
rownames(St_Ho) <- 'StHo'
}
StHo_res_perind <- lapply(Dat_perpop, StHo)
StHo_res_perind <- mapply(rbind, StHo_res_perind, "Pop"=names(StHo_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHo_res_perind <- t(as.data.frame(do.call("cbind", StHo_res_perind)))
StHo_res_perind <- as.data.frame(StHo_res_perind)
StHo_res_perind[,1] <- as.numeric(StHo_res_perind[,1])
View(StHo_res_perind)
StHo_res_perind <- lapply(Dat_perpop, StHo)
StHo_res_perind <- lapply(Dat_perpop, StHo)
# Estimate standardized heterozygosity based on the observed heterozyosity
StHo <- function(Dat){
St_Ho <- PropHt(Dat)/mean(ObsHet(Dat))
rownames(St_Ho) <- 'StHo'
}
StHo_res_perind <- lapply(Dat_perpop, StHo)
View(StHo_res_perind)
StHo <- function(Dat){
St_Ho <- PropHt(Dat)/mean(ObsHet(Dat))
rownames(St_Ho) <- 'StHo'
}
StHo_res_perind <- lapply(Dat_perpop, StHo)
View(StHo_res_perind)
# Estimate standardized heterozygosity based on the observed heterozyosity
StHo <- function(Dat){
St_Ho <- PropHt(Dat)/mean(ObsHet(Dat))
rownames(St_Ho) <- 'StHo'
return(St_Ho)
}
StHo_res_perind <- lapply(Dat_perpop, StHo)
View(StHo_res_perind)
StHo_res_perind <- mapply(rbind, StHo_res_perind, "Pop"=names(StHo_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHo_res_perind <- t(as.data.frame(do.call("cbind", StHo_res_perind)))
StHo_res_perind <- as.data.frame(StHo_res_perind)
StHo_res_perind[,1] <- as.numeric(StHo_res_perind[,1])
Output <- list(Obs_Het_res_avg, ObsHet_res_perloc, ExpHet_res_avg, ExpHet_res_perloc,
PropHt_res_perind, StHe_res_perind, StHo_res_perind)
names(Output) <- c("Ho_perpop", "Ho_perloc", "He_perpop", "He_perloc", "PHt", "StHe", "StHo")
res_write <- which(Stat %in% statistic)
Output2write <- Output[which(Stat_idx %in% res_write)]
View(Output2write)
i = 1
names(Output2write[[i]])
names(Output2write[i])
paste(names(Output2write[i]), ".csv", sep = "")
paste(prefix, names(Output2write[i]), ".csv", sep = "")
prefix = "Test"
paste(prefix, names(Output2write[i]), ".csv", sep = "")
paste(prefix, '_', names(Output2write[i]), ".csv", sep = "")
View(Output2write)
document()
library(devtools)
document
document()
document()
document()
rlang::last_trace()
rlang::last_trace(drop = FALSE)
document()
document()
check()
document()
check()
data("HornedLizard_Pop")
data("HornedLizard_VCF")
#' @return A list containing the estimated heterozygosity statistics. The per pop values are calculated by taking the average of the per locus estimates.
#' @export
#'
#' @examples
#' \donttest{
#' data("HornedLizard_Pop")
#' data("HornedLizard_VCF")
#' Test <- Heterozygosity(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)}
Heterozygosity <- function(data, pops, statistic = 'all', missing_value = NA, write = FALSE, prefix = NULL, population_col = NULL, individual_col = NULL) {
Statistic <- NULL
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds_popmap <- Pops[,1]
} else if(!is.null(individual_col)){
Inds_popmap <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
}
else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
}
else if(tools::file_ext(data) == 'geno'){
Dat <- utils::read.table(data)
print("Geno file detected, proceeding to formatting. Note, PopGenHelpR assumes that your individuals in the geno file and
popmap are in the same order, please check to avoid erroneous inferences.")
}
else {
stop("Please supply a geno file, vcf file, or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != Inds_popmap)){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != Inds_popmap)], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
} else if(tools::file_ext(data) == 'geno'){
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
} else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
# Replace missing data value with NA
if(is.na(missing_value) == FALSE){
Dat[Dat == missing_value] <- NA
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
if(is.na(missing_value) == FALSE){
Dat[Dat == missing_value] <- NA
}
# Break into list with populations for each element
Dat_perpop <- list()
for(i in unique(P)){
Dat_perpop[[i]] <- Dat[which(Dat[,2] == i),]
}
message('Formatting has finished, moving onto calculations')
#######################################
##### Heterozygosity calculations #####
#######################################
# Estimate observed heterozygosity (1-homozygosity), accounts for NA
ObsHet <- function(Dat){
ObsHet_perloc <- 1-(colSums(Dat[3:ncol(Dat)] != 1, na.rm = T)/(nrow(Dat)- colSums(is.na(Dat[3:ncol(Dat)]))))
return(ObsHet_perloc)
}
ObsHet_res_perloc  <- lapply(Dat_perpop, ObsHet)
Obs_Het_res_avg <- lapply(ObsHet_res_perloc, mean)
# Make it into a dataframe so that it is easier for users to view
ObsHet_res_perloc <- mapply(cbind, ObsHet_res_perloc, "Pop"=names(ObsHet_res_perloc), SIMPLIFY=F)
ObsHet_res_perloc <- as.data.frame(do.call("rbind", ObsHet_res_perloc))
colnames(ObsHet_res_perloc)[1] <- "Observed.Heterozygosity"
ObsHet_res_perloc[,1] <- as.numeric(ObsHet_res_perloc[,1])
Obs_Het_res_avg <- as.data.frame(do.call("rbind", Obs_Het_res_avg))
Obs_Het_res_avg$Pop <- rownames(Obs_Het_res_avg)
colnames(Obs_Het_res_avg)[1] <- "Observed.Heterozygosity"
Obs_Het_res_avg[,1] <- as.numeric(Obs_Het_res_avg[,1])
# Estimate expected heterozygosity
ExpHe <- function(Dat){
p <- ((colSums(Dat[3:ncol(Dat)]== 0, na.rm = T)*2) + colSums(Dat[3:ncol(Dat)]== 1, na.rm = T))/((nrow(Dat)- colSums(is.na(Dat[3:ncol(Dat)])))*2)
q <- ((colSums(Dat[3:ncol(Dat)]== 2, na.rm = T)*2) + colSums(Dat[3:ncol(Dat)]== 1, na.rm = T))/((nrow(Dat)- colSums(is.na(Dat[3:ncol(Dat)])))*2)
He_perloc <- 1-(p^2)-(q^2)
return(He_perloc)
}
ExpHet_res_perloc  <- lapply(Dat_perpop, ExpHe)
ExpHet_res_avg  <- lapply(ExpHet_res_perloc, mean)
# Make it into a dataframe so that it is easier for users to view
ExpHet_res_perloc <- mapply(cbind, ExpHet_res_perloc, "Pop"=names(ExpHet_res_perloc), SIMPLIFY=F)
ExpHet_res_perloc <- as.data.frame(do.call("rbind", ExpHet_res_perloc))
colnames(ExpHet_res_perloc)[1] <- "Expected.Heterozygosity"
ExpHet_res_perloc[,1] <- as.numeric(ExpHet_res_perloc[,1])
ExpHet_res_avg <- as.data.frame(do.call("rbind", ExpHet_res_avg))
ExpHet_res_avg$Pop <- rownames(ExpHet_res_avg)
colnames(ExpHet_res_avg)[1] <- "Expected.Heterozygosity"
ExpHet_res_avg[,1] <- as.numeric(ExpHet_res_avg[,1])
# Estimate the proportion of heterozygous loci per individual
PropHt <- function(Dat){
PHt <- t(as.data.frame(rowSums(Dat[3:ncol(Dat)] == 1, na.rm = T)/((ncol(Dat)-2) - rowSums(is.na(Dat[3:ncol(Dat)])))))
rownames(PHt) <- 'PHt'
colnames(PHt) <- Dat[,1]
return(PHt)
}
PropHt_res_perind <- lapply(Dat_perpop, PropHt)
PropHt_res_perind <- mapply(rbind, PropHt_res_perind, "Pop"=names(PropHt_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
PropHt_res_perind <- t(as.data.frame(do.call("cbind", PropHt_res_perind)))
PropHt_res_perind <- as.data.frame(PropHt_res_perind)
PropHt_res_perind[,1] <- as.numeric(PropHt_res_perind[,1])
# Estimate standardized heterozygosity based on the expected heterozygosity
StHe <- function(Dat){
St_He <- PropHt(Dat)/mean(ExpHe(Dat))
rownames(St_He) <- 'StHe'
return(St_He)
}
StHe_res_perind <- lapply(Dat_perpop, StHe)
StHe_res_perind <- mapply(rbind, StHe_res_perind, "Pop"=names(StHe_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHe_res_perind <- t(as.data.frame(do.call("cbind", StHe_res_perind)))
StHe_res_perind <- as.data.frame(StHe_res_perind)
StHe_res_perind[,1] <- as.numeric(StHe_res_perind[,1])
# Estimate standardized heterozygosity based on the observed heterozyosity
StHo <- function(Dat){
St_Ho <- PropHt(Dat)/mean(ObsHet(Dat))
rownames(St_Ho) <- 'StHo'
return(St_Ho)
}
StHo_res_perind <- lapply(Dat_perpop, StHo)
StHo_res_perind <- mapply(rbind, StHo_res_perind, "Pop"=names(StHo_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHo_res_perind <- t(as.data.frame(do.call("cbind", StHo_res_perind)))
StHo_res_perind <- as.data.frame(StHo_res_perind)
StHo_res_perind[,1] <- as.numeric(StHo_res_perind[,1])
# Estimate internal relatedness
IR <- NULL
# Estimate homozygosity by locus
HL <- NULL
Output <- list(Obs_Het_res_avg, ObsHet_res_perloc, ExpHet_res_avg, ExpHet_res_perloc,
PropHt_res_perind, StHe_res_perind, StHo_res_perind)
names(Output) <- c("Ho_perpop", "Ho_perloc", "He_perpop", "He_perloc", "PHt", "StHe", "StHo")
# Set list of possible statistics
Stat <- c("Ho", "He", "PHt", "StHe", "StHo", "IR", "HL")
Stat_idx <- c(1,1,2,2,3,4,5,6,7)
if(length(statistic) == 1 && Statistic ==  "all"){
return(Output)
} else {
res <- which(Stat %in% statistic)
Output_final<- Output[which(Stat_idx %in% res)]
return(Output_final)
}
if(write == TRUE && !is.null(prefix)){
res_write <- which(Stat %in% statistic)
Output2write <- Output[which(Stat_idx %in% res_write)]
for (i in 1:length(Output2write)){
utils::write.csv(Output2write, file = paste(names(Output2write[i]), ".csv", sep = ""))
}
} else if(write == TRUE && is.null(prefix)){
utils::write.csv(Output2write, file = paste(prefix, '_', names(Output2write[i]), ".csv", sep = ""))
}
}
Test <- Heterozygosity(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)
#' @return A list containing the estimated heterozygosity statistics. The per pop values are calculated by taking the average of the per locus estimates.
#' @export
#'
#' @examples
#' \donttest{
#' data("HornedLizard_Pop")
#' data("HornedLizard_VCF")
#' Test <- Heterozygosity(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)}
Heterozygosity <- function(data, pops, statistic = 'all', missing_value = NA, write = FALSE, prefix = NULL, population_col = NULL, individual_col = NULL) {
Statistic <- NULL
# Read in population assignment data
if(is.data.frame(pops)){
Pops <- pops
} else if(is.character(pops)){
Pops <- utils::read.csv(pops)
} else{
stop("Please supply a csv file or data frame for population assignment")
}
# Get the list of individuals from population assignment file
if(is.null(individual_col)) {
Inds_popmap <- Pops[,1]
} else if(!is.null(individual_col)){
Inds_popmap <- Pops[,individual_col]
}
# Read in files and convert to necessary formats
if(missing(data)){
stop("Please supply a file or vcfR object for analysis")
}
if(methods::is(data,"vcfR")){
Dat <- data
print("vcfR object detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
}
else if(tools::file_ext(data) == 'vcf') {
Dat <- vcfR::read.vcfR(data, verbose = FALSE)
print("VCF file detected, proceeding to formatting.")
# Convert the vcf gt slot to a geno style table for calculations
gt <- vcfR::extract.gt(Dat)
gt[gt == "0/0"] <- 0
gt[gt == "0/1" | gt == "1/0"] <- 1
gt[gt == "1/1"] <- 2
Dat <- as.data.frame(t(as.matrix(gt)))
# Preserve individual names
Inds <- rownames(Dat)
Dat <- sapply(Dat, as.numeric)
}
else if(tools::file_ext(data) == 'geno'){
Dat <- utils::read.table(data)
print("Geno file detected, proceeding to formatting. Note, PopGenHelpR assumes that your individuals in the geno file and
popmap are in the same order, please check to avoid erroneous inferences.")
}
else {
stop("Please supply a geno file, vcf file, or vcfR object for analysis")
}
P <- Pops
### Check to see if the individuals are in the same order in the vcf data and the population assignment file
# Make sure that the individuals in the vcf/genlight are in the same order as your popmap
if(methods::is(data,"vcfR") || tools::file_ext(data) == 'vcf') {
if(any(Inds != Inds_popmap)){
warning("Sample names in the VCF and Population file may not be in the same order or samples are missing,
The sample(s) in question are: ",
print(paste(Inds[(Inds != Inds_popmap)], collapse = ' ')))  }
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
}
else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
} else if(tools::file_ext(data) == 'geno'){
if(is.null(population_col)){
Pops <- as.factor(Pops[,2])
} else if(!is.null(population_col)){
Pops <- as.factor(Pops[,population_col])
}
}
# Replace missing data value with NA
if(is.na(missing_value) == FALSE){
Dat[Dat == missing_value] <- NA
}
P <- Pops
Dat <- cbind.data.frame(Inds, P, Dat)
if(is.na(missing_value) == FALSE){
Dat[Dat == missing_value] <- NA
}
# Break into list with populations for each element
Dat_perpop <- list()
for(i in unique(P)){
Dat_perpop[[i]] <- Dat[which(Dat[,2] == i),]
}
message('Formatting has finished, moving onto calculations')
#######################################
##### Heterozygosity calculations #####
#######################################
# Estimate observed heterozygosity (1-homozygosity), accounts for NA
ObsHet <- function(Dat){
ObsHet_perloc <- 1-(colSums(Dat[3:ncol(Dat)] != 1, na.rm = T)/(nrow(Dat)- colSums(is.na(Dat[3:ncol(Dat)]))))
return(ObsHet_perloc)
}
ObsHet_res_perloc  <- lapply(Dat_perpop, ObsHet)
Obs_Het_res_avg <- lapply(ObsHet_res_perloc, mean)
# Make it into a dataframe so that it is easier for users to view
ObsHet_res_perloc <- mapply(cbind, ObsHet_res_perloc, "Pop"=names(ObsHet_res_perloc), SIMPLIFY=F)
ObsHet_res_perloc <- as.data.frame(do.call("rbind", ObsHet_res_perloc))
colnames(ObsHet_res_perloc)[1] <- "Observed.Heterozygosity"
ObsHet_res_perloc[,1] <- as.numeric(ObsHet_res_perloc[,1])
Obs_Het_res_avg <- as.data.frame(do.call("rbind", Obs_Het_res_avg))
Obs_Het_res_avg$Pop <- rownames(Obs_Het_res_avg)
colnames(Obs_Het_res_avg)[1] <- "Observed.Heterozygosity"
Obs_Het_res_avg[,1] <- as.numeric(Obs_Het_res_avg[,1])
# Estimate expected heterozygosity
ExpHe <- function(Dat){
p <- ((colSums(Dat[3:ncol(Dat)]== 0, na.rm = T)*2) + colSums(Dat[3:ncol(Dat)]== 1, na.rm = T))/((nrow(Dat)- colSums(is.na(Dat[3:ncol(Dat)])))*2)
q <- ((colSums(Dat[3:ncol(Dat)]== 2, na.rm = T)*2) + colSums(Dat[3:ncol(Dat)]== 1, na.rm = T))/((nrow(Dat)- colSums(is.na(Dat[3:ncol(Dat)])))*2)
He_perloc <- 1-(p^2)-(q^2)
return(He_perloc)
}
ExpHet_res_perloc  <- lapply(Dat_perpop, ExpHe)
ExpHet_res_avg  <- lapply(ExpHet_res_perloc, mean)
# Make it into a dataframe so that it is easier for users to view
ExpHet_res_perloc <- mapply(cbind, ExpHet_res_perloc, "Pop"=names(ExpHet_res_perloc), SIMPLIFY=F)
ExpHet_res_perloc <- as.data.frame(do.call("rbind", ExpHet_res_perloc))
colnames(ExpHet_res_perloc)[1] <- "Expected.Heterozygosity"
ExpHet_res_perloc[,1] <- as.numeric(ExpHet_res_perloc[,1])
ExpHet_res_avg <- as.data.frame(do.call("rbind", ExpHet_res_avg))
ExpHet_res_avg$Pop <- rownames(ExpHet_res_avg)
colnames(ExpHet_res_avg)[1] <- "Expected.Heterozygosity"
ExpHet_res_avg[,1] <- as.numeric(ExpHet_res_avg[,1])
# Estimate the proportion of heterozygous loci per individual
PropHt <- function(Dat){
PHt <- t(as.data.frame(rowSums(Dat[3:ncol(Dat)] == 1, na.rm = T)/((ncol(Dat)-2) - rowSums(is.na(Dat[3:ncol(Dat)])))))
rownames(PHt) <- 'PHt'
colnames(PHt) <- Dat[,1]
return(PHt)
}
PropHt_res_perind <- lapply(Dat_perpop, PropHt)
PropHt_res_perind <- mapply(rbind, PropHt_res_perind, "Pop"=names(PropHt_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
PropHt_res_perind <- t(as.data.frame(do.call("cbind", PropHt_res_perind)))
PropHt_res_perind <- as.data.frame(PropHt_res_perind)
PropHt_res_perind[,1] <- as.numeric(PropHt_res_perind[,1])
# Estimate standardized heterozygosity based on the expected heterozygosity
StHe <- function(Dat){
St_He <- PropHt(Dat)/mean(ExpHe(Dat))
rownames(St_He) <- 'StHe'
return(St_He)
}
StHe_res_perind <- lapply(Dat_perpop, StHe)
StHe_res_perind <- mapply(rbind, StHe_res_perind, "Pop"=names(StHe_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHe_res_perind <- t(as.data.frame(do.call("cbind", StHe_res_perind)))
StHe_res_perind <- as.data.frame(StHe_res_perind)
StHe_res_perind[,1] <- as.numeric(StHe_res_perind[,1])
# Estimate standardized heterozygosity based on the observed heterozyosity
StHo <- function(Dat){
St_Ho <- PropHt(Dat)/mean(ObsHet(Dat))
rownames(St_Ho) <- 'StHo'
return(St_Ho)
}
StHo_res_perind <- lapply(Dat_perpop, StHo)
StHo_res_perind <- mapply(rbind, StHo_res_perind, "Pop"=names(StHo_res_perind), SIMPLIFY=F)
# Make it into a dataframe so that it is easier for users to view
StHo_res_perind <- t(as.data.frame(do.call("cbind", StHo_res_perind)))
StHo_res_perind <- as.data.frame(StHo_res_perind)
StHo_res_perind[,1] <- as.numeric(StHo_res_perind[,1])
# Estimate internal relatedness
IR <- NULL
# Estimate homozygosity by locus
HL <- NULL
Output <- list(Obs_Het_res_avg, ObsHet_res_perloc, ExpHet_res_avg, ExpHet_res_perloc,
PropHt_res_perind, StHe_res_perind, StHo_res_perind)
names(Output) <- c("Ho_perpop", "Ho_perloc", "He_perpop", "He_perloc", "PHt", "StHe", "StHo")
# Set list of possible statistics
Stat <- c("Ho", "He", "PHt", "StHe", "StHo", "IR", "HL")
Stat_idx <- c(1,1,2,2,3,4,5,6,7)
if(length(statistic) == 1 && statistic ==  "all"){
return(Output)
} else {
res <- which(Stat %in% statistic)
Output_final<- Output[which(Stat_idx %in% res)]
return(Output_final)
}
if(write == TRUE && !is.null(prefix)){
res_write <- which(Stat %in% statistic)
Output2write <- Output[which(Stat_idx %in% res_write)]
for (i in 1:length(Output2write)){
utils::write.csv(Output2write, file = paste(names(Output2write[i]), ".csv", sep = ""))
}
} else if(write == TRUE && is.null(prefix)){
utils::write.csv(Output2write, file = paste(prefix, '_', names(Output2write[i]), ".csv", sep = ""))
}
}
Test <- Heterozygosity(data = HornedLizard_VCF, pops = HornedLizard_Pop, write = FALSE)
document()
check()
