---
title: "PopGenHelpR Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{PopGenHelpR_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  options(rmarkdown.html_vignette.check_title = FALSE)
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
## Welcome
Welcome to the PopGenHelpR vignette, please contact the authors if you have any questions about the package. You can also visit our Github for additional examples (https://kfarleigh.github.io/PopGenHelpR/). 

```{r setup}
# Load the package
library(PopGenHelpR)
```

# Overview of PopGenHelpR
`PopGenHelpR` is a one-stop package for data analysis and visualization. `PopGenHelpR` can calculate commonly used population genomic statistics such as heterozygosity and genetic differentiation, with the functions `Heterozygosity`, `Differentiation`, and `Private.alleles`. While also producing publication-quality figures using the functions `Ancestry_barchart`, `Network_map`, `Pairwise_heatmap`, and `Piechart_map`. Check out the vignette below to see all of these functions in action!

### Assumptions of `PopGenHelpR`


#### Load the data 

First, we will load the data. These data objects are examples of data types that can be used in the functions in `PopGenHelpR`.

```{r load data}
data("Fst_dat")
data("Het_dat")
data("Q_dat")
data("HornedLizard_Pop")
data("HornedLizard_VCF")
```

## Genomic Analysis  

Statistical analysis is the foundation of any population genomics study, but many R packages only calculate a subset of commonly used population genomic statistics. `PopGenHelpR` seeks to remedy this by allowing researchers to calculate widely used diversity and differentiation measures in a single package. 

### Heterozygosity
Heterozygosity is a fundamental statistic in population genomics that allows researchers to evaluate the genetic diversity of individuals and populations. `PopGenHelpR` can estimate 7 measures of heterozygosity (individual and population). Here we will calculate observed heterozygosity, but please see the documentation for `Heterozygosity` to see all of the options. Better yet, check out our [article](https://kfarleigh.github.io/co) on heterozygosity and when to use each measure!


All we need is a vcf or geno file, population assignment file, and the statistic you wish to estimate (`PopGenHelpR` does them all by default). Note that `PopGenHelpR` assumes that the first column indicates sample names and the second column indicates the population to which each individual is assigned. You can use the arguments `individual_col` and `population_col` to specify which column indicates the sample and population names, respectively. You can also write the results to a csv if you set `write = TRUE`. 

```{r Heterozygosity, echo=TRUE, eval=FALSE}
Obs_Het <- Heterozygosity(data = HornedLizard_VCF, pops = HornedLizard_Pop, statistic = "Ho")
```

### Differentiaton
Differentiation is another basic analysis in population genomic studies. `PopGenHelpR` allows you to estimate ~*Fst*~, Nei's D (individual and population), and Jost's D. Like `Heterozygosity`, all we need is a vcf or geno file, population assignment file, and the statistic you want to calculate (`PopGenHelpR` does them all by default). Again, individual and population columns are assumed to be the first and second columns but can be indicated by users with `individual_col` and `population_col`, respectively.  

```{r Differentiation, echo=TRUE, eval=FALSE}
Fst <- Differentiation(data = HornedLizard_VCF, pops = HornedLizard_Pop, statistic = "Fst")
```

### Private alleles
Finally, we will calculate the number of private alleles in each population. This analysis is often used to evaluate signals of range expansion and helps researchers identify populations that harbor unique alleles. Note that `Private.alleles` can only use a vcf (no geno files) and does not require you to specify a statistic (all you absolutely need is a vcf and population file). Otherwise, it operates just like `Heterozygosity` or `Differentiation`. 

```{r Private.alleles, echo=TRUE, eval=FALSE}
PA <- Private.alleles(data = HornedLizard_VCF, pops = HornedLizard_Pop)
```


Let's move onto visualizations (the fun part), so you can get your work submitted!


## Visualizations 

### Ancestry Plots
`PopGenHelpR` can generate commonly used ancestry visualizations such as structure-like plots and ancestry piechart maps. First, we will create structure-like plots for individuals and populations. We need a q-matrix, population assignments for each individual, and the number of genetic clusters (K). The q-matrix represents the contribution of each cluster (K) to an individual or population and can be obtained from programs like STRUCTURE, ADMIXTURE, or sNMF. Please see our article on how to extract the q-matrix from these programs or email Keaka Farleigh. 

```{r Ancestry barchart, echo=TRUE, eval=FALSE}
# First, we seperate the list elements into two seperate objects. The q-matrix (Qmat) and the locality information for each individual (Loc).
Qmat <- Q_dat[[1]]
Loc <- Q_dat[[2]]

# Now we will generate both population and individual plots by setting plot.type to 'all'. If you wanted, you could only generate individual or population plots by setting plot.type to "individual" and "population", respectively.
Test_all <- Ancestry_barchart(anc.mat = Qmat, pops = Loc, K = 5,
plot.type = 'all', col = c('#d73027', '#f46d43', '#e0f3f8', '#74add1', '#313695'))

Test_all$`Individual Ancestry Plot`
```

```{r, out.width= "600px", out.height= "350px", echo=FALSE, eval=TRUE, fig.align='center'}
knitr::include_graphics("./img/Anc_barchart1.png")
```

We can also generate an ancestry matrix by populations. The ancestry of each population is calculate by averaging the ancestry of the individuals in a particular population. 

```{r, eval=FALSE}
Test_all$`Population Ancestry Plot`
```

```{r, out.width= "600px", out.height= "350px", echo=FALSE, eval=TRUE, fig.align='center'}
knitr::include_graphics("./img/Anc_barchart2.png")
```


Now, we will generate piechart maps of ancestry using the `Piechart_map` function. `Piechart_map` requires the same input as `Ancestry_barchart` with the additional requirement of coordinates for each individual/population. You'll notice that the individual map looks weird; the pie charts have a bunch of partitions. That's because we have multiple individuals at the same location, so the population map is probably a better choice. Instead of layering individuals on top of each other, the population map averages the ancestry of individuals in a population before mapping. See our GitHub for additional examples (https://kfarleigh.github.io/PopGenHelpR/).



```{r Piechart map, echo=TRUE, eval=FALSE, fig.align='center'}
# First, we seperate the list elements into two seperate objects. The q-matrix (Qmat) and the locality information for each individual (Loc).
Qmat <- Q_dat[[1]]
Loc <- Q_dat[[2]]

# Now we will generate both population and individual plots by setting plot.type to 'all'. If you wanted, you could only generate individual or population plots by setting plot.type to "individual" and "population", respectively.
Test_all_piemap <- Piechart_map(anc.mat = Qmat, pops = Loc, K = 5,plot.type = 'all', col = c('#d73027', '#f46d43', '#e0f3f8', '#74add1', '#313695'), 
                                Lat_buffer = 1, Long_buffer = 1)

Test_all_piemap$`Individual Map`
```

```{r, out.width= "500px", out.height= "750px", echo=FALSE, eval=TRUE, fig.align='center'}
knitr::include_graphics("./img/Ind_PieMap.png")
```


Notice the weird partitions? We can take care of those using the population piechart map. 

```{r Piechart map2, echo=TRUE, eval=FALSE, fig.align='center'}
Test_all_piemap$`Population Map`
```

```{r, out.width= "500px", out.height= "750px", echo=FALSE, eval=TRUE, fig.align='center'}
knitr::include_graphics("./img/Pop_PieMap.png")
```



## OLD STUFF BELOW

### Differentiation visualizations
We will use the `Fst_dat` object to visualize patterns of differentiation between populations. First, we will generate a heat map and then we will plot the realtionships on a map.
```{r Differentiation_old, echo = TRUE, eval=FALSE}
# Isolate our fst matrix and locality information
Fst <- Fst_dat[[1]]
Loc <- Fst_dat[[2]]
# Plot the heatmap, the statistic argument is used to label the plot.
Fstat_hmap <- Pairwise_heatmap(dat = Fst, statistic = 'FST')
# Look at the plot
Fstat_hmap
```

```{r, out.width= "600px", out.height= "350px", echo=FALSE, eval=TRUE}
knitr::include_graphics("./img/Differentiation-1.png")
```

The heatmap is useful, but what about putting it on a map? First we will set a numeric neighbors argument to plot the Fst estimate between each population's closest neighbor. Then we will specify relationships that we want to see using the population names.
```{r Differentiation map, echo = TRUE, eval=FALSE}
# Closest Neighbor
Fst_map <- Dif_Stats_Map(dat = Fst, pops = Loc, neighbors = 1,
                     col = c('#FFFF00','#FFC000','#FFA500','#e31a1c','#800026'),
                     Lat_buffer = 1, Long_buffer = 1)

Fst_map2 <- Dif_Stats_Map(dat = Fst, pops = Loc, neighbors = c('East_West', 'East_South', 'South_West'),
                     col = c('#FFFF00','#FFC000','#FFA500','#e31a1c','#800026'),
                     Lat_buffer = 1, Long_buffer = 1)

Fst_map$`Differentiation Map`
```


```{r, out.width= "600px", out.height= "350px", echo=FALSE, eval=TRUE}
knitr::include_graphics("./img/Differentiationmap-1.png")
```

```{r, echo = TRUE, eval = FALSE}
Fst_map2$`Differentiation Map`
```

```{r, out.width= "600px", out.height= "350px", echo=FALSE, eval=TRUE}
knitr::include_graphics("./img/Differentiationmap-2.png")
```

### Diversity Visualizations
Finally, we will map diversity values. We can color points based on diversity estimates and interpolated values to generate a raster to see how diversity changes across space. Here we only show the point method, but feel free to reach out if you have questions about the interpolation.
```{r Diversity, echo = TRUE, eval=FALSE}
# Similar to our heat map, we use the statistic argument to label our figures and any output raster you create.
Div_map <- Div_Stats_Map(dat = Het_dat, plot.type = 'point',
statistic = "Heterozygosity", col = c('blue', 'orange', 'red'), Lat_buffer = 1, Long_buffer = 1, prefix = 'Test_het')

Div_map$`Heterozygosity Map`
```

```{r, out.width= "600px", out.height= "350px", echo=FALSE, eval=TRUE}
knitr::include_graphics("./img/Diversity-1.png")
```

Thank you for your interest in our package, please reach out with any questions or things that should be included in future versions of the package.
